{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "30cc3ea5f96e462d6e112c8c4d9afe35", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a21e90a5584a3224e0683a3d0236f9ff", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples.paint/org/eclipse/swt/examples/paint/PaintSurface.java", "commitBeforeChange": "4dfad5a97535c7282afa88210ebbd2164a5fb922", "commitAfterChange": "15f1eee3a8ec2620bed875ba9786fc1d8ffa28db", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 24, "signatureBeforeChange": "\r\tpublic void scrollHorizontally(ScrollBar scrollBar)", "signatureAfterChange": "\r\tpublic void scrollHorizontally(ScrollBar scrollBar)", "diff": ["-\r\t/**\r\t * Returns the current paint status object.\r\t * \r\t * @return the current paint status object\r\t */\r\tpublic PaintStatus getPaintStatus() {\r\t\treturn paintStatus;\r\t}\r\r\t/**\r\t * Returns the current paint tool.\r\t * \r\t * @return the current paint tool, null if none is active (though some other session\r\t *         might be)\r\t */\r\tpublic PaintTool getPaintTool() {\r\t\treturn (paintSession != null && paintSession instanceof PaintTool) ?\r\t\t\t(PaintTool)paintSession : null;\r\t}\r\r\t/**\r\t * Returns the current position in an interactive operation.\r\t *\r\t * @return the last known position of the pointer\r\t */\r\tpublic Point getCurrentPosition() {\r\t\treturn currentPosition;\r\t}\r\t\r\t/**\r\t * Redraws a specified rectangular area using the backing store\r\t * \r\t * @param x the left X virtual coordinate of the region\r\t * @param y the top Y virtual coordinate of the region\r\t * @param width the width of the region\r\t * @param height the height of the region\r\t * @see getImageGC()\r\t */\r\tpublic void redrawArea(int x, int y, int width, int height) {\r\t\t// Clip to image and screen [computes intersection of the rectangles]\r\t\tfinal int clipX = Math.max(imageRect.x, visibleRect.x);\r\t\tif (x < clipX) {\r\t\t\twidth -= clipX - x;\r\t\t\tx = clipX;\r\t\t}\r\t\tfinal int clipY = Math.max(imageRect.y, visibleRect.y);\r\t\tif (y < clipY) {\r\t\t\theight -= clipY - y;\r\t\t\ty = clipY;\r\t\t}\r\t\tfinal int clipWidth = Math.min(imageRect.width, visibleRect.width) + clipX - x;\r\t\tif (width > clipWidth) width = clipWidth;\r\r\t\tfinal int clipHeight = Math.min(imageRect.height, visibleRect.height) + clipY - y;\r\t\tif (height > clipHeight) height = clipHeight;\r\r\t\tif (width < 0 || height < 0) return;\r\t\t\r\t\t// Redraw the region\r\t\thideRubberband();\r\t\tdisplayGC.drawImage(image, x - imageRect.x, y - imageRect.y, width, height,\r\t\t\tx - visibleRect.x, y - visibleRect.y, width, height);\r\t\tshowRubberband();\r\t}\r", "-\r\t/**\r\t * Draws a Figure object to the screen and to the backing store permanently.\r\t * \r\t * @param object the object to draw onscreen\r\t */\r\tpublic void drawFigure(Figure object) {\r\t\tobject.draw(getImageGC(), getImageOffset());\r\t\tobject.draw(getDisplayGC(), getDisplayOffset());\r\t}\r\r\t/**\r\t * Adds a Figure object to the active rubberband selection.\r\t * <p>\r\t * This object will be drawn to the screen as a preview and refreshed appropriately\r\t * until the selection is either cleared or committed.\r\t * </p>\r\t * \r\t * @param object the object to add to the selection\r\t */\r\tpublic void addRubberbandSelection(Figure object) {\r\t\tif (isRubberbandHidden()) {\r\t\t\trubberband.add(object);\r\t\t} else {\r\t\t\trubberbandState = rubberband.addAndPreview(object, rubberbandGC,\r\t\t\t\tgetDisplayOffset(), rubberbandState);\r\t\t}\r\t}\r\r\t/**\r\t * Clears the active rubberband selection.\r\t * <p>\r\t * Erases any rubberband objects on the screen then clears the selection.\r\t * </p>\r\t */\r\tpublic void clearRubberbandSelection() {\r\t\tif (! isRubberbandHidden()) {\r\t\t\trubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);\r\t\t\trubberbandState = null;\r\t\t}\r\t\trubberband.clear();\r\t}\r\r\t/**\r\t * Commits the active rubberband selection.\r\t * <p>\r\t * Redraws any rubberband objects on the screen as permanent objects then clears the selection.\r\t * </p>\r\t */\r\tpublic void commitRubberbandSelection() {\r\t\tif (! isRubberbandHidden()) {\r\t\t\trubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);\r\t\t\trubberbandState = null;\r\t\t}\r\t\tdrawFigure(rubberband);\r\t\trubberband.clear();\r\t}\r\t\r\t/**\r\t * Hides the rubberband (but does not eliminate it).\r\t * <p>\r\t * Increments by one the rubberband \"hide\" nesting count.  The rubberband\r\t * is hidden from view (but remains active) if it wasn't already hidden.\r\t * </p>\r\t */\r\tpublic void hideRubberband() {\r\t\tif (rubberbandHiddenNestingCount++ <= 0) {\r\t\t\trubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);\r\t\t\trubberbandState = null;\r\t\t}\r\t}\t\t\r\r\t/**\r\t * Shows (un-hides) the rubberband.\r\t * <p>\r\t * Decrements by one the rubberband \"hide\" nesting count.  The rubberband\r\t * is only made visible when showRubberband() has been called once for each\r\t * previous hideRubberband().  It is not permitted to call showRubberband() if\r\t * the rubber band is not presently hidden.\r\t * </p>\r\t */\r\tpublic void showRubberband() {\r\t\tif (rubberbandHiddenNestingCount <= 0)\r\t\t\tthrow new IllegalStateException(\"rubberbandHiddenNestingCount > 0\");\r\t\tif (--rubberbandHiddenNestingCount == 0) {\r\t\t\trubberbandState = rubberband.drawPreview(rubberbandGC, getDisplayOffset());\r\t\t}\r\t}\r\t\r\t/**\r\t * Determines if the rubberband is hidden.\r\t * \r\t * @return true iff the rubber is hidden\r\t */\r\tpublic boolean isRubberbandHidden() {\r\t\treturn rubberbandHiddenNestingCount > 0;\r\t}\r\r\t/**\r\t * Displays the current position in the status bar.\r\t */\r\tpublic void showCurrentPositionStatus() {\r\t\tpaintStatus.setCoord(currentPosition);\r\t}\r\r\t/**\r\t * Displays the current position in the status bar.\r\t */\r\tpublic void showCurrentRangeStatus(Point anchorPosition) {\r\t\tpaintStatus.setCoordRange(anchorPosition, currentPosition);\r\t}\r\r\t/**\r\t * Handles a horizontal scroll event\r\t * \r\t * @param scrollbar the horizontal scroll bar that posted this event\r\t */\r\tpublic void scrollHorizontally(ScrollBar scrollBar) {\r\t\tif (image == null) return;\r\t\tif (imageRect.width > visibleRect.width) {\r\t\t\tfinal int oldx = visibleRect.x;\r\r\t\t\tvisibleRect.x = Math.min(scrollBar.getSelection(), imageRect.width - visibleRect.width);\r\t\t\tpaintCanvas.scroll(Math.max(oldx - visibleRect.x, 0), 0, Math.max(visibleRect.x - oldx, 0), 0,\r\t\t\t\tvisibleRect.width, visibleRect.height, false);\r\t\t}\r\t}\r\r\t/**\r\t * Handles a vertical scroll event\r\t * \r\t * @param scrollbar the vertical scroll bar that posted this event\r\t */\r\tpublic void scrollVertically(ScrollBar scrollBar) {\r\t\tif (image == null) return;\r\t\tif (imageRect.height > visibleRect.height) {\r\t\t\tfinal int oldy = visibleRect.y;\r\r\t\t\tvisibleRect.y = Math.min(scrollBar.getSelection(), imageRect.height - visibleRect.height);\r\t\t\tpaintCanvas.scroll(0, Math.max(oldy - visibleRect.y, 0), 0, Math.max(visibleRect.y - oldy, 0),\r\t\t\t\tvisibleRect.width, visibleRect.height, false);\r\t\t}\r\t}\r\t\r\t/**\r\t * Handles resize events\r\t */\r\tprivate void handleResize() {\r\t\tvisibleRect = paintCanvas.getClientArea();\r\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\tif (horizontal != null) {\r\t\t\tvisibleRect.x = Math.min(horizontal.getSelection(), imageRect.width - visibleRect.width);\r\t\t\tif (imageRect.width <= visibleRect.width) {\r\t\t\t\thorizontal.setEnabled(false);\r\t\t\t\thorizontal.setSelection(0);\r\t\t\t} else {\r\t\t\t\tfinal int max = imageRect.width - visibleRect.width;\r\t\t\t\thorizontal.setEnabled(true);\r\t\t\t\thorizontal.setValues(visibleRect.x, 0, imageRect.width, visibleRect.width,\r\t\t\t\t\t8, visibleRect.width);\r\t\t\t}\r\t\t}\r\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tif (vertical != null) {\r\t\t\tvisibleRect.y = Math.min(vertical.getSelection(), imageRect.height - visibleRect.height);\r\t\t\tif (imageRect.height <= visibleRect.height) {\r\t\t\t\tvertical.setEnabled(false);\r\t\t\t\tvertical.setSelection(0);\r\t\t\t} else {\r\t\t\t\tfinal int max = imageRect.height - visibleRect.height;\r\t\t\t\tvertical.setEnabled(true);\r\t\t\t\tvertical.setValues(visibleRect.y, 0, imageRect.height, visibleRect.height,\r\t\t\t\t\t8, visibleRect.height);\r\t\t\t}\r\t\t}\r\t}\r\r\t/**\r\t * Virtualizes MouseEvent coordinates and stores the current position.\r\t */\r\tprivate void processMouseEventCoordinates(MouseEvent event) {\r\t\tcurrentPosition.x = event.x =\r\t\t\tMath.min(Math.max(event.x, 0), visibleRect.width - 1) + visibleRect.x;\r\t\tcurrentPosition.y = event.y =\r\t\t\tMath.min(Math.max(event.y, 0), visibleRect.height - 1) + visibleRect.y;\r\t}\r}\r", "+\r\t/**\r\t * Returns the current paint tool.\r\t * \r\t * @return the current paint tool, null if none is active (though some other session\r\t *         might be)\r\t */\r\tpublic PaintTool getPaintTool() {\r\t\treturn (paintSession != null && paintSession instanceof PaintTool) ?\r\t\t\t(PaintTool)paintSession : null;\r\t}\r\r\t/**\r\t * Returns the current position in an interactive operation.\r\t *\r\t * @return the last known position of the pointer\r\t */\r\tpublic Point getCurrentPosition() {\r\t\treturn currentPosition;\r\t}\r\r\t/**\r\t * Draws a Figure object to the screen and to the backing store permanently.\r\t * \r\t * @param object the object to draw onscreen\r\t */\r\tpublic void drawFigure(Figure object) {\r\t\tobject.draw(imageFDC);\r\t\tobject.draw(displayFDC);\r\t}\r\r\t/**\r\t * Adds a Figure object to the active rubberband selection.\r\t * <p>\r\t * This object will be drawn to the screen as a preview and refreshed appropriately\r\t * until the selection is either cleared or committed.\r\t * </p>\r\t * \r\t * @param object the object to add to the selection\r\t */\r\tpublic void addRubberbandSelection(Figure object) {\r\t\trubberband.add(object);\r\t\tif (! isRubberbandHidden()) object.draw(displayFDC);\r\t}\r\r\t/**\r\t * Clears the active rubberband selection.\r\t * <p>\r\t * Erases any rubberband objects on the screen then clears the selection.\r\t * </p>\r\t */\r\tpublic void clearRubberbandSelection() {\r\t\tif (! isRubberbandHidden()) {\r\t\t\tRegion region = new Region();\r\t\t\trubberband.addDamagedRegion(displayFDC, region);\r\t\t\tRectangle r = region.getBounds();\r\t\t\tpaintCanvas.redraw(r.x, r.y, r.width, r.height, true);\r\t\t\tregion.dispose();\r\t\t}\r\t\trubberband.clear();\r\r\t}\r\r\t/**\r\t * Commits the active rubberband selection.\r\t * <p>\r\t * Redraws any rubberband objects on the screen as permanent objects then clears the selection.\r\t * </p>\r\t */\r\tpublic void commitRubberbandSelection() {\r\t\trubberband.draw(imageFDC);\r\t\tif (isRubberbandHidden()) rubberband.draw(displayFDC);\r\t\trubberband.clear();\r\t}\r\t\r\t/**\r\t * Hides the rubberband (but does not eliminate it).\r\t * <p>\r\t * Increments by one the rubberband \"hide\" nesting count.  The rubberband\r\t * is hidden from view (but remains active) if it wasn't already hidden.\r\t * </p>\r\t */\r\tpublic void hideRubberband() {\r\t\tif (rubberbandHiddenNestingCount++ <= 0) {\r\t\t\tRegion region = new Region();\r\t\t\trubberband.addDamagedRegion(displayFDC, region);\r\t\t\tRectangle r = region.getBounds();\r\t\t\tpaintCanvas.redraw(r.x, r.y, r.width, r.height, true);\r\t\t\tregion.dispose();\r\t\t}\r\t}\t\t\r\r\t/**\r\t * Shows (un-hides) the rubberband.\r\t * <p>\r\t * Decrements by one the rubberband \"hide\" nesting count.  The rubberband\r\t * is only made visible when showRubberband() has been called once for each\r\t * previous hideRubberband().  It is not permitted to call showRubberband() if\r\t * the rubber band is not presently hidden.\r\t * </p>\r\t */\r\tpublic void showRubberband() {\r\t\tif (rubberbandHiddenNestingCount <= 0)\r\t\t\tthrow new IllegalStateException(\"rubberbandHiddenNestingCount > 0\");\r\t\tif (--rubberbandHiddenNestingCount == 0) {\r\t\t\trubberband.draw(displayFDC);\r\t\t}\r\t}\r\t\r\t/**\r\t * Determines if the rubberband is hidden.\r\t * \r\t * @return true iff the rubber is hidden\r\t */\r\tpublic boolean isRubberbandHidden() {\r\t\treturn rubberbandHiddenNestingCount > 0;\r\t}\r\r\t/**\r\t * Handles a horizontal scroll event\r\t * \r\t * @param scrollbar the horizontal scroll bar that posted this event\r\t */\r\tpublic void scrollHorizontally(ScrollBar scrollBar) {\r\t\tif (image == null) return;\r\t\tif (imageWidth > visibleWidth) {\r\t\t\tfinal int oldx = displayFDC.xOffset;\r\t\t\tdisplayFDC.xOffset = Math.min(scrollBar.getSelection(), imageWidth - visibleWidth);\r\t\t\tpaintCanvas.scroll(Math.max(oldx - displayFDC.xOffset, 0), 0, Math.max(displayFDC.xOffset - oldx, 0), 0,\r\t\t\t\tvisibleWidth, visibleHeight, false);\r\t\t}\r\t}\r\r\t/**\r\t * Handles a vertical scroll event\r\t * \r\t * @param scrollbar the vertical scroll bar that posted this event\r\t */\r\tpublic void scrollVertically(ScrollBar scrollBar) {\r\t\tif (image == null) return;\r\t\tif (imageHeight > visibleHeight) {\r\t\t\tfinal int oldy = displayFDC.yOffset;\r\r\t\t\tdisplayFDC.yOffset = Math.min(scrollBar.getSelection(), imageHeight - visibleHeight);\r\t\t\tpaintCanvas.scroll(0, Math.max(oldy - displayFDC.yOffset, 0), 0, Math.max(displayFDC.yOffset - oldy, 0),\r\t\t\t\tvisibleWidth, visibleHeight, false);\r\t\t}\r\t}\r\t\r\t/**\r\t * Handles resize events\r\t */\r\tprivate void handleResize() {\r\t\tRectangle visibleRect = paintCanvas.getClientArea();\r\t\tvisibleWidth = visibleRect.width;\r\t\tvisibleHeight = visibleRect.height;\r\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\tif (horizontal != null) {\r\t\t\tdisplayFDC.xOffset = Math.min(horizontal.getSelection(), imageWidth - visibleWidth);\r\t\t\tif (imageWidth <= visibleWidth) {\r\t\t\t\thorizontal.setEnabled(false);\r\t\t\t\thorizontal.setSelection(0);\r\t\t\t} else {\r\t\t\t\tfinal int max = imageWidth - visibleWidth;\r\t\t\t\thorizontal.setEnabled(true);\r\t\t\t\thorizontal.setValues(displayFDC.xOffset, 0, imageWidth, visibleWidth,\r\t\t\t\t\t8, visibleWidth);\r\t\t\t}\r\t\t}\r\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tif (vertical != null) {\r\t\t\tdisplayFDC.yOffset = Math.min(vertical.getSelection(), imageHeight - visibleHeight);\r\t\t\tif (imageHeight <= visibleHeight) {\r\t\t\t\tvertical.setEnabled(false);\r\t\t\t\tvertical.setSelection(0);\r\t\t\t} else {\r\t\t\t\tfinal int max = imageHeight - visibleHeight;\r\t\t\t\tvertical.setEnabled(true);\r\t\t\t\tvertical.setValues(displayFDC.yOffset, 0, imageHeight, visibleHeight,\r\t\t\t\t\t8, visibleHeight);\r\t\t\t}\r\t\t}\r\t}\r\r\t/**\r\t * Virtualizes MouseEvent coordinates and stores the current position.\r\t */\r\tprivate void processMouseEventCoordinates(MouseEvent event) {\r\t\tcurrentPosition.x = event.x =\r\t\t\tMath.min(Math.max(event.x, 0), visibleWidth - 1) + displayFDC.xOffset;\r\t\tcurrentPosition.y = event.y =\r\t\t\tMath.min(Math.max(event.y, 0), visibleHeight - 1) + displayFDC.yOffset;\r\t}\r\t\r\t/**\r\t * Clears the status bar.\r\t */\r\tpublic void clearStatus() {\r\t\tstatusActionInfo = \"\";\r\t\tstatusMessageInfo = \"\";\r\t\tstatusCoordInfo = \"\";\r\t\tupdateStatus();\r\t}\r\r\t/**\r\t * Sets the status bar action text.\r\t *\r\t * @param action the action in progress, null to clear\r\t */\r\tpublic void setStatusAction(String action) {\r\t\tstatusActionInfo = (action != null) ? action : \"\";\r\t\tupdateStatus();\r\t}\r\t\r\t/**\r\t * Sets the status bar message text.\r\t * \r\t * @param message the message to display, null to clear\r\t */\r\tpublic void setStatusMessage(String message) {\r\t\tstatusMessageInfo = (message != null) ? message : \"\";\r\t\tupdateStatus();\r\t}\r\r\t/**\r\t * Sets the coordinates in the status bar.\r\t * \r\t * @param coord the coordinates to display, null to clear\r\t */\r\tpublic void setStatusCoord(Point coord) {\r\t\tstatusCoordInfo = (coord != null) ? PaintPlugin.getResourceString(\"status.Coord.format\", new Object[]\r\t\t\t{ new Integer(coord.x), new Integer(coord.y)}) : \"\";\r\t\tupdateStatus();\r\t}\r\r\t/**\r\t * Sets the coordinate range in the status bar.\r\t * \r\t * @param a the \"from\" coordinate, must not be null\r\t * @param b the \"to\" coordinate, must not be null\r\t */\r\tpublic void setStatusCoordRange(Point a, Point b) {\r\t\tstatusCoordInfo = PaintPlugin.getResourceString(\"status.CoordRange.format\", new Object[]\r\t\t\t{ new Integer(a.x), new Integer(a.y), new Integer(b.x), new Integer(b.y)});\r\t\tupdateStatus();\r\t}\r\r\t/**\r\t * Updates the display.\r\t */\r\tprivate void updateStatus() {\r\t\tstatusText.setText(\r\t\t\tPaintPlugin.getResourceString(\"status.Bar.format\", new Object[]\r\t\t\t{ statusActionInfo, statusMessageInfo, statusCoordInfo }));\r\t}\r}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0db002488a24a0d365fa55a76b320df4", "repository": "http://git.eclipse.org/gitroot/platform/eclipse.platform.swt.git", "fileName": "examples/org.eclipse.swt.examples.paint/src/org/eclipse/swt/examples/paint/PaintSurface.java", "commitBeforeChange": "4dfad5a97535c7282afa88210ebbd2164a5fb922", "commitAfterChange": "15f1eee3a8ec2620bed875ba9786fc1d8ffa28db", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 24, "signatureBeforeChange": "\r\tpublic void scrollHorizontally(ScrollBar scrollBar)", "signatureAfterChange": "\r\tpublic void scrollHorizontally(ScrollBar scrollBar)", "diff": ["-\r\t/**\r\t * Returns the current paint status object.\r\t * \r\t * @return the current paint status object\r\t */\r\tpublic PaintStatus getPaintStatus() {\r\t\treturn paintStatus;\r\t}\r\r\t/**\r\t * Returns the current paint tool.\r\t * \r\t * @return the current paint tool, null if none is active (though some other session\r\t *         might be)\r\t */\r\tpublic PaintTool getPaintTool() {\r\t\treturn (paintSession != null && paintSession instanceof PaintTool) ?\r\t\t\t(PaintTool)paintSession : null;\r\t}\r\r\t/**\r\t * Returns the current position in an interactive operation.\r\t *\r\t * @return the last known position of the pointer\r\t */\r\tpublic Point getCurrentPosition() {\r\t\treturn currentPosition;\r\t}\r\t\r\t/**\r\t * Redraws a specified rectangular area using the backing store\r\t * \r\t * @param x the left X virtual coordinate of the region\r\t * @param y the top Y virtual coordinate of the region\r\t * @param width the width of the region\r\t * @param height the height of the region\r\t * @see getImageGC()\r\t */\r\tpublic void redrawArea(int x, int y, int width, int height) {\r\t\t// Clip to image and screen [computes intersection of the rectangles]\r\t\tfinal int clipX = Math.max(imageRect.x, visibleRect.x);\r\t\tif (x < clipX) {\r\t\t\twidth -= clipX - x;\r\t\t\tx = clipX;\r\t\t}\r\t\tfinal int clipY = Math.max(imageRect.y, visibleRect.y);\r\t\tif (y < clipY) {\r\t\t\theight -= clipY - y;\r\t\t\ty = clipY;\r\t\t}\r\t\tfinal int clipWidth = Math.min(imageRect.width, visibleRect.width) + clipX - x;\r\t\tif (width > clipWidth) width = clipWidth;\r\r\t\tfinal int clipHeight = Math.min(imageRect.height, visibleRect.height) + clipY - y;\r\t\tif (height > clipHeight) height = clipHeight;\r\r\t\tif (width < 0 || height < 0) return;\r\t\t\r\t\t// Redraw the region\r\t\thideRubberband();\r\t\tdisplayGC.drawImage(image, x - imageRect.x, y - imageRect.y, width, height,\r\t\t\tx - visibleRect.x, y - visibleRect.y, width, height);\r\t\tshowRubberband();\r\t}\r", "-\r\t/**\r\t * Draws a Figure object to the screen and to the backing store permanently.\r\t * \r\t * @param object the object to draw onscreen\r\t */\r\tpublic void drawFigure(Figure object) {\r\t\tobject.draw(getImageGC(), getImageOffset());\r\t\tobject.draw(getDisplayGC(), getDisplayOffset());\r\t}\r\r\t/**\r\t * Adds a Figure object to the active rubberband selection.\r\t * <p>\r\t * This object will be drawn to the screen as a preview and refreshed appropriately\r\t * until the selection is either cleared or committed.\r\t * </p>\r\t * \r\t * @param object the object to add to the selection\r\t */\r\tpublic void addRubberbandSelection(Figure object) {\r\t\tif (isRubberbandHidden()) {\r\t\t\trubberband.add(object);\r\t\t} else {\r\t\t\trubberbandState = rubberband.addAndPreview(object, rubberbandGC,\r\t\t\t\tgetDisplayOffset(), rubberbandState);\r\t\t}\r\t}\r\r\t/**\r\t * Clears the active rubberband selection.\r\t * <p>\r\t * Erases any rubberband objects on the screen then clears the selection.\r\t * </p>\r\t */\r\tpublic void clearRubberbandSelection() {\r\t\tif (! isRubberbandHidden()) {\r\t\t\trubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);\r\t\t\trubberbandState = null;\r\t\t}\r\t\trubberband.clear();\r\t}\r\r\t/**\r\t * Commits the active rubberband selection.\r\t * <p>\r\t * Redraws any rubberband objects on the screen as permanent objects then clears the selection.\r\t * </p>\r\t */\r\tpublic void commitRubberbandSelection() {\r\t\tif (! isRubberbandHidden()) {\r\t\t\trubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);\r\t\t\trubberbandState = null;\r\t\t}\r\t\tdrawFigure(rubberband);\r\t\trubberband.clear();\r\t}\r\t\r\t/**\r\t * Hides the rubberband (but does not eliminate it).\r\t * <p>\r\t * Increments by one the rubberband \"hide\" nesting count.  The rubberband\r\t * is hidden from view (but remains active) if it wasn't already hidden.\r\t * </p>\r\t */\r\tpublic void hideRubberband() {\r\t\tif (rubberbandHiddenNestingCount++ <= 0) {\r\t\t\trubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);\r\t\t\trubberbandState = null;\r\t\t}\r\t}\t\t\r\r\t/**\r\t * Shows (un-hides) the rubberband.\r\t * <p>\r\t * Decrements by one the rubberband \"hide\" nesting count.  The rubberband\r\t * is only made visible when showRubberband() has been called once for each\r\t * previous hideRubberband().  It is not permitted to call showRubberband() if\r\t * the rubber band is not presently hidden.\r\t * </p>\r\t */\r\tpublic void showRubberband() {\r\t\tif (rubberbandHiddenNestingCount <= 0)\r\t\t\tthrow new IllegalStateException(\"rubberbandHiddenNestingCount > 0\");\r\t\tif (--rubberbandHiddenNestingCount == 0) {\r\t\t\trubberbandState = rubberband.drawPreview(rubberbandGC, getDisplayOffset());\r\t\t}\r\t}\r\t\r\t/**\r\t * Determines if the rubberband is hidden.\r\t * \r\t * @return true iff the rubber is hidden\r\t */\r\tpublic boolean isRubberbandHidden() {\r\t\treturn rubberbandHiddenNestingCount > 0;\r\t}\r\r\t/**\r\t * Displays the current position in the status bar.\r\t */\r\tpublic void showCurrentPositionStatus() {\r\t\tpaintStatus.setCoord(currentPosition);\r\t}\r\r\t/**\r\t * Displays the current position in the status bar.\r\t */\r\tpublic void showCurrentRangeStatus(Point anchorPosition) {\r\t\tpaintStatus.setCoordRange(anchorPosition, currentPosition);\r\t}\r\r\t/**\r\t * Handles a horizontal scroll event\r\t * \r\t * @param scrollbar the horizontal scroll bar that posted this event\r\t */\r\tpublic void scrollHorizontally(ScrollBar scrollBar) {\r\t\tif (image == null) return;\r\t\tif (imageRect.width > visibleRect.width) {\r\t\t\tfinal int oldx = visibleRect.x;\r\r\t\t\tvisibleRect.x = Math.min(scrollBar.getSelection(), imageRect.width - visibleRect.width);\r\t\t\tpaintCanvas.scroll(Math.max(oldx - visibleRect.x, 0), 0, Math.max(visibleRect.x - oldx, 0), 0,\r\t\t\t\tvisibleRect.width, visibleRect.height, false);\r\t\t}\r\t}\r\r\t/**\r\t * Handles a vertical scroll event\r\t * \r\t * @param scrollbar the vertical scroll bar that posted this event\r\t */\r\tpublic void scrollVertically(ScrollBar scrollBar) {\r\t\tif (image == null) return;\r\t\tif (imageRect.height > visibleRect.height) {\r\t\t\tfinal int oldy = visibleRect.y;\r\r\t\t\tvisibleRect.y = Math.min(scrollBar.getSelection(), imageRect.height - visibleRect.height);\r\t\t\tpaintCanvas.scroll(0, Math.max(oldy - visibleRect.y, 0), 0, Math.max(visibleRect.y - oldy, 0),\r\t\t\t\tvisibleRect.width, visibleRect.height, false);\r\t\t}\r\t}\r\t\r\t/**\r\t * Handles resize events\r\t */\r\tprivate void handleResize() {\r\t\tvisibleRect = paintCanvas.getClientArea();\r\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\tif (horizontal != null) {\r\t\t\tvisibleRect.x = Math.min(horizontal.getSelection(), imageRect.width - visibleRect.width);\r\t\t\tif (imageRect.width <= visibleRect.width) {\r\t\t\t\thorizontal.setEnabled(false);\r\t\t\t\thorizontal.setSelection(0);\r\t\t\t} else {\r\t\t\t\tfinal int max = imageRect.width - visibleRect.width;\r\t\t\t\thorizontal.setEnabled(true);\r\t\t\t\thorizontal.setValues(visibleRect.x, 0, imageRect.width, visibleRect.width,\r\t\t\t\t\t8, visibleRect.width);\r\t\t\t}\r\t\t}\r\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tif (vertical != null) {\r\t\t\tvisibleRect.y = Math.min(vertical.getSelection(), imageRect.height - visibleRect.height);\r\t\t\tif (imageRect.height <= visibleRect.height) {\r\t\t\t\tvertical.setEnabled(false);\r\t\t\t\tvertical.setSelection(0);\r\t\t\t} else {\r\t\t\t\tfinal int max = imageRect.height - visibleRect.height;\r\t\t\t\tvertical.setEnabled(true);\r\t\t\t\tvertical.setValues(visibleRect.y, 0, imageRect.height, visibleRect.height,\r\t\t\t\t\t8, visibleRect.height);\r\t\t\t}\r\t\t}\r\t}\r\r\t/**\r\t * Virtualizes MouseEvent coordinates and stores the current position.\r\t */\r\tprivate void processMouseEventCoordinates(MouseEvent event) {\r\t\tcurrentPosition.x = event.x =\r\t\t\tMath.min(Math.max(event.x, 0), visibleRect.width - 1) + visibleRect.x;\r\t\tcurrentPosition.y = event.y =\r\t\t\tMath.min(Math.max(event.y, 0), visibleRect.height - 1) + visibleRect.y;\r\t}\r}\r", "+\r\t/**\r\t * Returns the current paint tool.\r\t * \r\t * @return the current paint tool, null if none is active (though some other session\r\t *         might be)\r\t */\r\tpublic PaintTool getPaintTool() {\r\t\treturn (paintSession != null && paintSession instanceof PaintTool) ?\r\t\t\t(PaintTool)paintSession : null;\r\t}\r\r\t/**\r\t * Returns the current position in an interactive operation.\r\t *\r\t * @return the last known position of the pointer\r\t */\r\tpublic Point getCurrentPosition() {\r\t\treturn currentPosition;\r\t}\r\r\t/**\r\t * Draws a Figure object to the screen and to the backing store permanently.\r\t * \r\t * @param object the object to draw onscreen\r\t */\r\tpublic void drawFigure(Figure object) {\r\t\tobject.draw(imageFDC);\r\t\tobject.draw(displayFDC);\r\t}\r\r\t/**\r\t * Adds a Figure object to the active rubberband selection.\r\t * <p>\r\t * This object will be drawn to the screen as a preview and refreshed appropriately\r\t * until the selection is either cleared or committed.\r\t * </p>\r\t * \r\t * @param object the object to add to the selection\r\t */\r\tpublic void addRubberbandSelection(Figure object) {\r\t\trubberband.add(object);\r\t\tif (! isRubberbandHidden()) object.draw(displayFDC);\r\t}\r\r\t/**\r\t * Clears the active rubberband selection.\r\t * <p>\r\t * Erases any rubberband objects on the screen then clears the selection.\r\t * </p>\r\t */\r\tpublic void clearRubberbandSelection() {\r\t\tif (! isRubberbandHidden()) {\r\t\t\tRegion region = new Region();\r\t\t\trubberband.addDamagedRegion(displayFDC, region);\r\t\t\tRectangle r = region.getBounds();\r\t\t\tpaintCanvas.redraw(r.x, r.y, r.width, r.height, true);\r\t\t\tregion.dispose();\r\t\t}\r\t\trubberband.clear();\r\r\t}\r\r\t/**\r\t * Commits the active rubberband selection.\r\t * <p>\r\t * Redraws any rubberband objects on the screen as permanent objects then clears the selection.\r\t * </p>\r\t */\r\tpublic void commitRubberbandSelection() {\r\t\trubberband.draw(imageFDC);\r\t\tif (isRubberbandHidden()) rubberband.draw(displayFDC);\r\t\trubberband.clear();\r\t}\r\t\r\t/**\r\t * Hides the rubberband (but does not eliminate it).\r\t * <p>\r\t * Increments by one the rubberband \"hide\" nesting count.  The rubberband\r\t * is hidden from view (but remains active) if it wasn't already hidden.\r\t * </p>\r\t */\r\tpublic void hideRubberband() {\r\t\tif (rubberbandHiddenNestingCount++ <= 0) {\r\t\t\tRegion region = new Region();\r\t\t\trubberband.addDamagedRegion(displayFDC, region);\r\t\t\tRectangle r = region.getBounds();\r\t\t\tpaintCanvas.redraw(r.x, r.y, r.width, r.height, true);\r\t\t\tregion.dispose();\r\t\t}\r\t}\t\t\r\r\t/**\r\t * Shows (un-hides) the rubberband.\r\t * <p>\r\t * Decrements by one the rubberband \"hide\" nesting count.  The rubberband\r\t * is only made visible when showRubberband() has been called once for each\r\t * previous hideRubberband().  It is not permitted to call showRubberband() if\r\t * the rubber band is not presently hidden.\r\t * </p>\r\t */\r\tpublic void showRubberband() {\r\t\tif (rubberbandHiddenNestingCount <= 0)\r\t\t\tthrow new IllegalStateException(\"rubberbandHiddenNestingCount > 0\");\r\t\tif (--rubberbandHiddenNestingCount == 0) {\r\t\t\trubberband.draw(displayFDC);\r\t\t}\r\t}\r\t\r\t/**\r\t * Determines if the rubberband is hidden.\r\t * \r\t * @return true iff the rubber is hidden\r\t */\r\tpublic boolean isRubberbandHidden() {\r\t\treturn rubberbandHiddenNestingCount > 0;\r\t}\r\r\t/**\r\t * Handles a horizontal scroll event\r\t * \r\t * @param scrollbar the horizontal scroll bar that posted this event\r\t */\r\tpublic void scrollHorizontally(ScrollBar scrollBar) {\r\t\tif (image == null) return;\r\t\tif (imageWidth > visibleWidth) {\r\t\t\tfinal int oldx = displayFDC.xOffset;\r\t\t\tdisplayFDC.xOffset = Math.min(scrollBar.getSelection(), imageWidth - visibleWidth);\r\t\t\tpaintCanvas.scroll(Math.max(oldx - displayFDC.xOffset, 0), 0, Math.max(displayFDC.xOffset - oldx, 0), 0,\r\t\t\t\tvisibleWidth, visibleHeight, false);\r\t\t}\r\t}\r\r\t/**\r\t * Handles a vertical scroll event\r\t * \r\t * @param scrollbar the vertical scroll bar that posted this event\r\t */\r\tpublic void scrollVertically(ScrollBar scrollBar) {\r\t\tif (image == null) return;\r\t\tif (imageHeight > visibleHeight) {\r\t\t\tfinal int oldy = displayFDC.yOffset;\r\r\t\t\tdisplayFDC.yOffset = Math.min(scrollBar.getSelection(), imageHeight - visibleHeight);\r\t\t\tpaintCanvas.scroll(0, Math.max(oldy - displayFDC.yOffset, 0), 0, Math.max(displayFDC.yOffset - oldy, 0),\r\t\t\t\tvisibleWidth, visibleHeight, false);\r\t\t}\r\t}\r\t\r\t/**\r\t * Handles resize events\r\t */\r\tprivate void handleResize() {\r\t\tRectangle visibleRect = paintCanvas.getClientArea();\r\t\tvisibleWidth = visibleRect.width;\r\t\tvisibleHeight = visibleRect.height;\r\r\t\tScrollBar horizontal = paintCanvas.getHorizontalBar();\r\t\tif (horizontal != null) {\r\t\t\tdisplayFDC.xOffset = Math.min(horizontal.getSelection(), imageWidth - visibleWidth);\r\t\t\tif (imageWidth <= visibleWidth) {\r\t\t\t\thorizontal.setEnabled(false);\r\t\t\t\thorizontal.setSelection(0);\r\t\t\t} else {\r\t\t\t\tfinal int max = imageWidth - visibleWidth;\r\t\t\t\thorizontal.setEnabled(true);\r\t\t\t\thorizontal.setValues(displayFDC.xOffset, 0, imageWidth, visibleWidth,\r\t\t\t\t\t8, visibleWidth);\r\t\t\t}\r\t\t}\r\r\t\tScrollBar vertical = paintCanvas.getVerticalBar();\r\t\tif (vertical != null) {\r\t\t\tdisplayFDC.yOffset = Math.min(vertical.getSelection(), imageHeight - visibleHeight);\r\t\t\tif (imageHeight <= visibleHeight) {\r\t\t\t\tvertical.setEnabled(false);\r\t\t\t\tvertical.setSelection(0);\r\t\t\t} else {\r\t\t\t\tfinal int max = imageHeight - visibleHeight;\r\t\t\t\tvertical.setEnabled(true);\r\t\t\t\tvertical.setValues(displayFDC.yOffset, 0, imageHeight, visibleHeight,\r\t\t\t\t\t8, visibleHeight);\r\t\t\t}\r\t\t}\r\t}\r\r\t/**\r\t * Virtualizes MouseEvent coordinates and stores the current position.\r\t */\r\tprivate void processMouseEventCoordinates(MouseEvent event) {\r\t\tcurrentPosition.x = event.x =\r\t\t\tMath.min(Math.max(event.x, 0), visibleWidth - 1) + displayFDC.xOffset;\r\t\tcurrentPosition.y = event.y =\r\t\t\tMath.min(Math.max(event.y, 0), visibleHeight - 1) + displayFDC.yOffset;\r\t}\r\t\r\t/**\r\t * Clears the status bar.\r\t */\r\tpublic void clearStatus() {\r\t\tstatusActionInfo = \"\";\r\t\tstatusMessageInfo = \"\";\r\t\tstatusCoordInfo = \"\";\r\t\tupdateStatus();\r\t}\r\r\t/**\r\t * Sets the status bar action text.\r\t *\r\t * @param action the action in progress, null to clear\r\t */\r\tpublic void setStatusAction(String action) {\r\t\tstatusActionInfo = (action != null) ? action : \"\";\r\t\tupdateStatus();\r\t}\r\t\r\t/**\r\t * Sets the status bar message text.\r\t * \r\t * @param message the message to display, null to clear\r\t */\r\tpublic void setStatusMessage(String message) {\r\t\tstatusMessageInfo = (message != null) ? message : \"\";\r\t\tupdateStatus();\r\t}\r\r\t/**\r\t * Sets the coordinates in the status bar.\r\t * \r\t * @param coord the coordinates to display, null to clear\r\t */\r\tpublic void setStatusCoord(Point coord) {\r\t\tstatusCoordInfo = (coord != null) ? PaintPlugin.getResourceString(\"status.Coord.format\", new Object[]\r\t\t\t{ new Integer(coord.x), new Integer(coord.y)}) : \"\";\r\t\tupdateStatus();\r\t}\r\r\t/**\r\t * Sets the coordinate range in the status bar.\r\t * \r\t * @param a the \"from\" coordinate, must not be null\r\t * @param b the \"to\" coordinate, must not be null\r\t */\r\tpublic void setStatusCoordRange(Point a, Point b) {\r\t\tstatusCoordInfo = PaintPlugin.getResourceString(\"status.CoordRange.format\", new Object[]\r\t\t\t{ new Integer(a.x), new Integer(a.y), new Integer(b.x), new Integer(b.y)});\r\t\tupdateStatus();\r\t}\r\r\t/**\r\t * Updates the display.\r\t */\r\tprivate void updateStatus() {\r\t\tstatusText.setText(\r\t\t\tPaintPlugin.getResourceString(\"status.Bar.format\", new Object[]\r\t\t\t{ statusActionInfo, statusMessageInfo, statusCoordInfo }));\r\t}\r}\r"]}], "num": 4}