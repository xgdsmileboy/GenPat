/* Generated By:JavaCC: Do not edit this line. ACParser.java */
/*BEGIN_COPYRIGHT_BLOCK
 *
 * This file is part of DrJava.  Download the current version of this project:
 * http://sourceforge.net/projects/drjava/ or http://www.drjava.org/
 *
 * DrJava Open Source License
 * 
 * Copyright (C) 2001-2003 JavaPLT group at Rice University (javaplt@rice.edu)
 * All rights reserved.
 *
 * Developed by:   Java Programming Languages Team
 *                 Rice University
 *                 http://www.cs.rice.edu/~javaplt/
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"),
 * to deal with the Software without restriction, including without 
 * limitation the rights to use, copy, modify, merge, publish, distribute, 
 * sublicense, and/or sell copies of the Software, and to permit persons to 
 * whom the Software is furnished to do so, subject to the following 
 * conditions:
 * 
 *     - Redistributions of source code must retain the above copyright 
 *       notice, this list of conditions and the following disclaimers.
 *     - Redistributions in binary form must reproduce the above copyright 
 *       notice, this list of conditions and the following disclaimers in the
 *       documentation and/or other materials provided with the distribution.
 *     - Neither the names of DrJava, the JavaPLT, Rice University, nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this Software without specific prior written permission.
 *     - Products derived from this software may not be called "DrJava" nor
 *       use the term "DrJava" as part of their names without prior written
 *       permission from the JavaPLT group.  For permission, write to
 *       javaplt@rice.edu.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
 * THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR 
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
 * OTHER DEALINGS WITH THE SOFTWARE.
 * 
END_COPYRIGHT_BLOCK*/

package edu.rice.cs.drjava.model.autocomplete.parser;



import java.io.File;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.StringReader;
import java.util.ListIterator;
import java.util.LinkedList;
import java.math.BigInteger;

//import edu.rice.cs.javaast.*;
//import edu.rice.cs.javaast.Visibility;
//import edu.rice.cs.javaast.ClassModifier;
//import edu.rice.cs.javaast.SourceInfo;
//import edu.rice.cs.javaast.CharConverter;
import edu.rice.cs.javalanglevels.*;
import edu.rice.cs.javalanglevels.tree.*;

public class ACParser implements ACParserConstants {
  public static final SourceInfo NO_SOURCE_INFO = new SourceInfo(null, -1, -1, -1, -1);

  public static final ClassOrInterfaceType NO_TYPE = new ClassOrInterfaceType(NO_SOURCE_INFO, "Object", new Type[0]);
  public static final VariableInitializerI NO_VARIABLE_INITIALIZER = new NoVariableInitializer(NO_SOURCE_INFO);
  public static final EmptyForInit EMPTY_FOR_INIT = new EmptyForInit(NO_SOURCE_INFO);
  public static final EmptyForUpdate EMPTY_FOR_UPDATE = new EmptyForUpdate(NO_SOURCE_INFO);
  public static final EmptyForCondition EMPTY_FOR_CONDITION = new EmptyForCondition(NO_SOURCE_INFO);
  public static final NoAllocationQualifier NO_ALLOCATION_QUALIFIER = new NoAllocationQualifier(NO_SOURCE_INFO);
  public static final NoAllocationExpression NO_ALLOCATION_EXPRESSION= new NoAllocationExpression(NO_SOURCE_INFO);
  private boolean _inInterface;

//  private Vector<ParseException> _errors;
  private static File _currentFile;
  public static void main(String args[]) {
    ACParser parser;
//    _errors = new Vector<ParseException>();
    if (args.length == 0) {
      System.out.println("JExpression Parser Version 1.0.2:  Reading from standard input . . .");
      parser = new ACParser(System.in);
    } else if (args.length == 1) {
      System.out.println("JExpression Parser Version 1.0.2:  Reading from file " + args[0] + " . . .");
      try {
        _currentFile = new File(args[0]);
        parser = new ACParser(new java.io.FileInputStream(_currentFile));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("JExpression Parser Version 1.0.2:  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("JExpression Parser Version 1.0.2:  Usage is one of:");
      System.out.println("         java JavaParser < inputfile");
      System.out.println("OR");
      System.out.println("         java JavaParser inputfile");
      return;
    }
    try {
      parser.SourceFile();
      System.out.println("JExpression Parser Version 1.0.2:  Java program parsed successfully.");
    } catch (ParseException e) {
      System.out.println("JExpression Parser Version 1.0.2:  Encountered errors during parse.");
    }
  }

  public ACParser(File file) throws FileNotFoundException {
    this(new FileReader(file));
    _currentFile = file;
  }

  public ACParser(String file) {
    this(new StringReader(file));
    _currentFile = null;
  }

  /** Strips off the "l" or "L" off the end of long literals */
  private static String _stripL(String in) {
    if (in.endsWith("l") || in.endsWith("L")) {
      return in.substring(0, in.length() - 1);
    }
    else {
      return in;
    }
  }

  /** Returns in without first and last character. */
  private static String _stripQuotes(String in) {
    int len = in.length();

    return in.substring(1, len - 1);
  }

  /**
   * Creates a source location that starts at the given first token
   * and ends in the last token yet read.
   */
  private SourceInfo _loc(Token first) {
    return new SourceInfo(_currentFile,
                          first.beginLine,
                          first.beginColumn,
                          token.endLine,
                          token.endColumn);
  }

  /**
   * Creates a source location that starts at the given first AST piece
   * and ends in the last token yet read.
   */
  private SourceInfo _loc(JExpressionIF first) {
    return new SourceInfo(_currentFile,
                          first.getSourceInfo().getStartLine(),
                          first.getSourceInfo().getStartColumn(),
                          token.endLine,
                          token.endColumn);
  }

  private void _throwParseException(String message) throws ParseException {
    // The error typically occurs on the next token.
    Token t = token;
    if (token.next != null) {
      t = token.next;
    }
    // If a certain token or sequence of tokens is expected, display it.
    ParseException pe = generateParseException();
//    if (pe.expectedTokenSequences.length == 1) {
//      message += " Expected";
//      for (int i = 0; i < pe.expectedTokenSequences.length; i++) {
//        message += " " + pe.tokenImage[pe.expectedTokenSequences[0][i]];
//      }
//      message += ".";
//    }
    throw new ParseException(_currentFile, message, t, pe.expectedTokenSequences, tokenImage);
//    _errors.add(new ParseException(_currentFile, message, t, null, tokenImage);
  }

      private void _throwParseException(ParseException pe, String message) throws ParseException {
    // Use the embedded error message if thrown from our code
    if (pe.customConstructor) {
      message = pe.getMessage();
    }
    _throwParseException(message);
  }

  private String _getTokenImage() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < tokenImage.length; i++) {
      sb.append(tokenImage[i] + " ");
    }
    return new String(sb).trim();
  }

  private boolean _isAbstract(ModifiersAndVisibility mav) {
    String[] modifiers = mav.getModifiers();
    for (int i = 0; i < modifiers.length; i++) {
      if (modifiers[i].equals("abstract")) {
        return true;
      }
    }
    return false;
  }

  void _errorChar(char c) throws ParseException {
    _throwParseException("'" + c + "' expected.");
  }

  boolean _ignoreChar(char c) throws ParseException {
    return true;
  }

  void _errorString(String s) throws ParseException {
    StringBuffer message = new StringBuffer();
    for (int i = 0; i < s.length(); i++) {
      if (i > 0) {
        if (i == (s.length() - 1)) {
          message.append(" or ");
        }
        else {
          message.append(", ");
        }
      }
      message.append(s.charAt(i));
    }
    _throwParseException(message.toString() + " expected.");
  }

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */
  final public SourceFile SourceFile() throws ParseException {
  LinkedList<PackageStatement> packageStatements = new LinkedList<PackageStatement>();
  LinkedList<ImportStatement> importStatements = new LinkedList<ImportStatement>();
  LinkedList<ClassDef> classes = new LinkedList<ClassDef>();
  LinkedList<InterfaceDef> interfaces = new LinkedList<InterfaceDef>();
  PackageStatement temp1;
  ImportStatement temp2;
  ClassDef temp3;
  InterfaceDef temp4;
  Token temp5;
  Token first = getToken(1);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CASE:
        case CATCH:
        case CHAR:
        case CLASS:
        case CONST:
        case CONTINUE:
        case _DEFAULT:
        case DO:
        case DOUBLE:
        case ELSE:
        case EXTENDS:
        case FALSE:
        case FINAL:
        case FINALLY:
        case FLOAT:
        case FOR:
        case GOTO:
        case IF:
        case IMPLEMENTS:
        case IMPORT:
        case INSTANCEOF:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case NEW:
        case NULL:
        case PACKAGE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case RETURN:
        case SHORT:
        case STRICTFP:
        case STATIC:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case THROWS:
        case TRANSIENT:
        case TRUE:
        case TRY:
        case VOID:
        case VOLATILE:
        case WHILE:
        case DECIMAL_LITERAL:
        case HEX_LITERAL:
        case OCTAL_LITERAL:
        case LONG_DECIMAL_LITERAL:
        case LONG_HEX_LITERAL:
        case LONG_OCTAL_LITERAL:
        case DOUBLE_FLOATING_POINT_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case RPAREN:
        case LBRACE:
        case RBRACE:
        case LBRACKET:
        case RBRACKET:
        case SEMICOLON:
        case COMMA:
        case DOT:
        case ASSIGN:
        case GT:
        case LT:
        case BANG:
        case TILDE:
        case HOOK:
        case COLON:
        case EQ:
        case LE:
        case GE:
        case NE:
        case SC_OR:
        case SC_AND:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case BIT_AND:
        case BIT_OR:
        case XOR:
        case REM:
        case LSHIFT:
        case RSIGNEDSHIFT:
        case RSSHIFT1:
        case RSSHIFT2:
        case RUSHIFT1:
        case RUSHIFT2:
        case RUSHIFT3:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:
        case OTHER:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        if (jj_2_1(2147483647)) {
          temp2 = ImportStatement();
         importStatements.addLast(temp2);
        } else if (jj_2_2(2147483647)) {
          temp1 = PackageStatement();
          packageStatements.addLast(temp1);
        } else if (jj_2_3(2147483647)) {
          temp3 = ClassDef();
      classes.addLast(temp3);
        } else if (jj_2_4(2147483647)) {
          temp4 = InterfaceDef();
       interfaces.addLast(temp4);
        } else if (jj_2_5(2147483647)) {
          AnyTokenButEOF();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(0);
       {if (true) return new SourceFile(_loc(first),
                             packageStatements.toArray(new PackageStatement[0]),
                             importStatements.toArray(new ImportStatement[0]),
                             classes.toArray(new ClassDef[0]),
                             interfaces.toArray(new InterfaceDef[0]));}
    } catch (ParseException pe) {
//    if (pe.currentToken.next != null && pe.currentToken.next.kind == EOF) {
//      _throwParseException(pe, "'}' expected.");
//    }
//    else {
    /** Hmm, how to also indicate that interfaces can appear here w/o messing up elementary level? */
      _throwParseException(pe, "A class declaration must appear here: found " + getToken(1));
//    }

    }
    throw new Error("Missing return statement in function");
  }

  final public void AnyTokenButEOF() throws ParseException {
    LinkedList<String> words = new LinkedList<String>();
    Token t = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
      t = jj_consume_token(ABSTRACT);
      break;
    case BOOLEAN:
      t = jj_consume_token(BOOLEAN);
      break;
    case BREAK:
      t = jj_consume_token(BREAK);
      break;
    case BYTE:
      t = jj_consume_token(BYTE);
      break;
    case CASE:
      t = jj_consume_token(CASE);
      break;
    case CATCH:
      t = jj_consume_token(CATCH);
      break;
    case CHAR:
      t = jj_consume_token(CHAR);
      break;
    case CLASS:
      t = jj_consume_token(CLASS);
      break;
    case CONST:
      t = jj_consume_token(CONST);
      break;
    case CONTINUE:
      t = jj_consume_token(CONTINUE);
      break;
    case _DEFAULT:
      t = jj_consume_token(_DEFAULT);
      break;
    case DO:
      t = jj_consume_token(DO);
      break;
    case DOUBLE:
      t = jj_consume_token(DOUBLE);
      break;
    case ELSE:
      t = jj_consume_token(ELSE);
      break;
    case EXTENDS:
      t = jj_consume_token(EXTENDS);
      break;
    case FALSE:
      t = jj_consume_token(FALSE);
      break;
    case FINAL:
      t = jj_consume_token(FINAL);
      break;
    case FINALLY:
      t = jj_consume_token(FINALLY);
      break;
    case FLOAT:
      t = jj_consume_token(FLOAT);
      break;
    case FOR:
      t = jj_consume_token(FOR);
      break;
    case GOTO:
      t = jj_consume_token(GOTO);
      break;
    case IF:
      t = jj_consume_token(IF);
      break;
    case IMPLEMENTS:
      t = jj_consume_token(IMPLEMENTS);
      break;
    case IMPORT:
      t = jj_consume_token(IMPORT);
      break;
    case INSTANCEOF:
      t = jj_consume_token(INSTANCEOF);
      break;
    case INT:
      t = jj_consume_token(INT);
      break;
    case INTERFACE:
      t = jj_consume_token(INTERFACE);
      break;
    case LONG:
      t = jj_consume_token(LONG);
      break;
    case NATIVE:
      t = jj_consume_token(NATIVE);
      break;
    case NEW:
      t = jj_consume_token(NEW);
      break;
    case NULL:
      t = jj_consume_token(NULL);
      break;
    case PACKAGE:
      t = jj_consume_token(PACKAGE);
      break;
    case PRIVATE:
      t = jj_consume_token(PRIVATE);
      break;
    case PROTECTED:
      t = jj_consume_token(PROTECTED);
      break;
    case PUBLIC:
      t = jj_consume_token(PUBLIC);
      break;
    case RETURN:
      t = jj_consume_token(RETURN);
      break;
    case SHORT:
      t = jj_consume_token(SHORT);
      break;
    case STRICTFP:
      t = jj_consume_token(STRICTFP);
      break;
    case STATIC:
      t = jj_consume_token(STATIC);
      break;
    case SUPER:
      t = jj_consume_token(SUPER);
      break;
    case SWITCH:
      t = jj_consume_token(SWITCH);
      break;
    case SYNCHRONIZED:
      t = jj_consume_token(SYNCHRONIZED);
      break;
    case THIS:
      t = jj_consume_token(THIS);
      break;
    case THROW:
      t = jj_consume_token(THROW);
      break;
    case THROWS:
      t = jj_consume_token(THROWS);
      break;
    case TRANSIENT:
      t = jj_consume_token(TRANSIENT);
      break;
    case TRUE:
      t = jj_consume_token(TRUE);
      break;
    case TRY:
      t = jj_consume_token(TRY);
      break;
    case VOID:
      t = jj_consume_token(VOID);
      break;
    case VOLATILE:
      t = jj_consume_token(VOLATILE);
      break;
    case WHILE:
      t = jj_consume_token(WHILE);
      break;
    case DECIMAL_LITERAL:
      t = jj_consume_token(DECIMAL_LITERAL);
      break;
    case HEX_LITERAL:
      t = jj_consume_token(HEX_LITERAL);
      break;
    case OCTAL_LITERAL:
      t = jj_consume_token(OCTAL_LITERAL);
      break;
    case LONG_DECIMAL_LITERAL:
      t = jj_consume_token(LONG_DECIMAL_LITERAL);
      break;
    case LONG_HEX_LITERAL:
      t = jj_consume_token(LONG_HEX_LITERAL);
      break;
    case LONG_OCTAL_LITERAL:
      t = jj_consume_token(LONG_OCTAL_LITERAL);
      break;
    case DOUBLE_FLOATING_POINT_LITERAL:
      t = jj_consume_token(DOUBLE_FLOATING_POINT_LITERAL);
      break;
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
      break;
    case CHARACTER_LITERAL:
      t = jj_consume_token(CHARACTER_LITERAL);
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      break;
    case LPAREN:
      t = jj_consume_token(LPAREN);
      break;
    case RPAREN:
      t = jj_consume_token(RPAREN);
      break;
    case LBRACE:
      t = jj_consume_token(LBRACE);
      break;
    case RBRACE:
      t = jj_consume_token(RBRACE);
      break;
    case LBRACKET:
      t = jj_consume_token(LBRACKET);
      break;
    case RBRACKET:
      t = jj_consume_token(RBRACKET);
      break;
    case SEMICOLON:
      t = jj_consume_token(SEMICOLON);
      break;
    case COMMA:
      t = jj_consume_token(COMMA);
      break;
    case DOT:
      t = jj_consume_token(DOT);
      break;
    case ASSIGN:
      t = jj_consume_token(ASSIGN);
      break;
    case GT:
      t = jj_consume_token(GT);
      break;
    case LT:
      t = jj_consume_token(LT);
      break;
    case BANG:
      t = jj_consume_token(BANG);
      break;
    case TILDE:
      t = jj_consume_token(TILDE);
      break;
    case HOOK:
      t = jj_consume_token(HOOK);
      break;
    case COLON:
      t = jj_consume_token(COLON);
      break;
    case EQ:
      t = jj_consume_token(EQ);
      break;
    case LE:
      t = jj_consume_token(LE);
      break;
    case GE:
      t = jj_consume_token(GE);
      break;
    case NE:
      t = jj_consume_token(NE);
      break;
    case SC_OR:
      t = jj_consume_token(SC_OR);
      break;
    case SC_AND:
      t = jj_consume_token(SC_AND);
      break;
    case INCR:
      t = jj_consume_token(INCR);
      break;
    case DECR:
      t = jj_consume_token(DECR);
      break;
    case PLUS:
      t = jj_consume_token(PLUS);
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
      break;
    case STAR:
      t = jj_consume_token(STAR);
      break;
    case SLASH:
      t = jj_consume_token(SLASH);
      break;
    case BIT_AND:
      t = jj_consume_token(BIT_AND);
      break;
    case BIT_OR:
      t = jj_consume_token(BIT_OR);
      break;
    case XOR:
      t = jj_consume_token(XOR);
      break;
    case REM:
      t = jj_consume_token(REM);
      break;
    case LSHIFT:
      t = jj_consume_token(LSHIFT);
      break;
    case RSIGNEDSHIFT:
      t = jj_consume_token(RSIGNEDSHIFT);
      break;
    case RSSHIFT1:
      t = jj_consume_token(RSSHIFT1);
      break;
    case RSSHIFT2:
      t = jj_consume_token(RSSHIFT2);
      break;
    case RUSHIFT1:
      t = jj_consume_token(RUSHIFT1);
      break;
    case RUSHIFT2:
      t = jj_consume_token(RUSHIFT2);
      break;
    case RUSHIFT3:
      t = jj_consume_token(RUSHIFT3);
      break;
    case PLUSASSIGN:
      t = jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      t = jj_consume_token(MINUSASSIGN);
      break;
    case STARASSIGN:
      t = jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      t = jj_consume_token(SLASHASSIGN);
      break;
    case ANDASSIGN:
      t = jj_consume_token(ANDASSIGN);
      break;
    case ORASSIGN:
      t = jj_consume_token(ORASSIGN);
      break;
    case XORASSIGN:
      t = jj_consume_token(XORASSIGN);
      break;
    case REMASSIGN:
      t = jj_consume_token(REMASSIGN);
      break;
    case LSHIFTASSIGN:
      t = jj_consume_token(LSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGN:
      t = jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      t = jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    case OTHER:
      t = jj_consume_token(OTHER);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
//    System.out.println("chewing: " + t.image);
      words.addLast(t.image);
      getToken(1);
  }

//JExpression JExpression() :
//{
//  JExpression ret;
//}
//{
//  ( ret = Operator() |
//    LOOKAHEAD(MethodDefLookahead())
//    ret = MethodDef() |
//    LOOKAHEAD(VariableDeclarationLookahead())
//    ret = VariableDeclaration() |
//    LOOKAHEAD(<IDENTIFIER> <DOT>)
//    ret = CompoundWord() |   
//    ret = Word() |
//    ret = Literal() |
//    ret = Bracketed() |
//    ret = Braced() |
//    ret = Parenthesized() |
//    LOOKAHEAD( ( <ABSTRACT> | <FINAL> | <PUBLIC> | <STRICTFP> )* <CLASS> )
//    ret = ClassDef() |
//    LOOKAHEAD( ( <STATIC> | <ABSTRACT> | <FINAL> | <PUBLIC> | <PROTECTED> | <PRIVATE> )* <INTERFACE> )
//    ret = InterfaceDef() |
////    ret = CommaSeparatedList() |
//    //ret = AngleBracketed() |
////    ret = LineCommented() |
////    ret = BlockCommented() |
////    ret = DocCommented() |
//    ret = Statement()
////    ret = BracedStatement()
//     
//  )
//  {
//    return ret;
//  }
//}
  final public void MethodDefLookahead() throws ParseException {
    ModifiersAndVisibility();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      TypeParameters();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    ReturnType();
    jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
  }

  final public void ConstructorDefLookahead() throws ParseException {
    ModifiersAndVisibility();
    jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      FormalParameter();
      break;
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// This production is to determine lookahead only.  It will be used instead
// of MethodDefLookahead because of the added complexity of
// parametric methods and types fooling the lookahead.
  final public void VariableDeclarationLookahead() throws ParseException {
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case TRANSIENT:
      case VOLATILE:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        jj_consume_token(PUBLIC);
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
        break;
      case PRIVATE:
        jj_consume_token(PRIVATE);
        break;
      case STATIC:
        jj_consume_token(STATIC);
        break;
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
        break;
      case FINAL:
        jj_consume_token(FINAL);
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    Type();
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case ASSIGN:
      jj_consume_token(ASSIGN);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    case LBRACKET:
      jj_consume_token(LBRACKET);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Literal Literal() throws ParseException {
  Token t;
  Literal literal;
  Token first = getToken(1);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:
        literal = IntegerLiteral(false, first);
                                             {if (true) return literal;}
        break;
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:
        literal = FloatLiteral();
                                 {if (true) return literal;}
        break;
      case CHARACTER_LITERAL:
        t = jj_consume_token(CHARACTER_LITERAL);
                                {if (true) return new CharLiteral(_loc(t), CharConverter.unescapeChar(_stripQuotes(t.image)));}
        break;
      case STRING_LITERAL:
        t = jj_consume_token(STRING_LITERAL);
                             {if (true) return new StringLiteral(_loc(t), CharConverter.unescapeString(_stripQuotes(t.image)));}
        break;
      case FALSE:
      case TRUE:
        literal = BooleanLiteral();
                                   {if (true) return literal;}
        break;
      case NULL:
        jj_consume_token(NULL);
               {if (true) return new NullLiteral(_loc(first));}
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
    _throwParseException(pe, "This is an illegal literal!");
    }
    throw new Error("Missing return statement in function");
  }

  final public PackageStatement PackageStatement() throws ParseException {
  CompoundWord cw;
  Token first = getToken(1);
    jj_consume_token(PACKAGE);
    try {
      cw = CompoundWord();
     //{ System.out.println("cw = " + cw); 
      {if (true) return new PackageStatement(_loc(first), cw);}
    } catch (ParseException pe) {
    _throwParseException(pe, "Illegal package name!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ImportStatement ImportStatement() throws ParseException {
  CompoundWord cw;
  Token first = getToken(1);
    jj_consume_token(IMPORT);
    cw = CompoundWord();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        jj_consume_token(STAR);
      {if (true) return new PackageImportStatement(_loc(first), cw);}
        break;
      default:
        jj_la1[8] = jj_gen;
      {if (true) return new ClassImportStatement(_loc(first), cw);}
      }
    } catch (ParseException pe) {
    _throwParseException(pe, "Illegal import name!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ModifiersAndVisibility ModifiersAndVisibility() throws ParseException {
  LinkedList<String> words = new LinkedList<String>();
  Token t;
  Token first = getToken(1);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STRICTFP:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        t = jj_consume_token(PUBLIC);
        break;
      case PROTECTED:
        t = jj_consume_token(PROTECTED);
        break;
      case PRIVATE:
        t = jj_consume_token(PRIVATE);
        break;
      case STATIC:
        t = jj_consume_token(STATIC);
        break;
      case ABSTRACT:
        t = jj_consume_token(ABSTRACT);
        break;
      case FINAL:
        t = jj_consume_token(FINAL);
        break;
      case TRANSIENT:
        t = jj_consume_token(TRANSIENT);
        break;
      case VOLATILE:
        t = jj_consume_token(VOLATILE);
        break;
      case NATIVE:
        t = jj_consume_token(NATIVE);
        break;
      case SYNCHRONIZED:
        t = jj_consume_token(SYNCHRONIZED);
        break;
      case STRICTFP:
        t = jj_consume_token(STRICTFP);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
//   System.out.println("adding " + t.image);
     words.addLast(t.image);
    }
   // If there are no modifiers, then we make our own SourceInfo that
   // points to the beginning of the following token.
   // Otherwise, the coordinates are backwards.
    SourceInfo si;
    if (words.size() == 0) {
      si = new SourceInfo(_currentFile,
                          first.beginLine,
                          first.beginColumn,
                          first.beginLine,
                          first.beginColumn);
    }
    else {
      si = _loc(first);
    }
    {if (true) return new ModifiersAndVisibility(si, words.toArray(new String[0]));}
    throw new Error("Missing return statement in function");
  }

  final public ClassDef ClassDef() throws ParseException {
  ModifiersAndVisibility modifiers;
  UnmodifiedClassDef decl;
  Token first = getToken(1);
//  System.out.println("looking at: " + first.image);
  _inInterface = false;
    modifiers = ModifiersAndVisibility();
    decl = UnmodifiedClassDef();
    // parse the modifiers later
//    if ((mav.isStatic) ||
//        (mav.visibility == Visibility.PRIVATE) ||
//        (mav.visibility == Visibility.PROTECTED))
//    {
//      throw new RuntimeException("Invalid modifiers for top-level class!");
//    }

    {if (true) return new ClassDef(_loc(first),
                        modifiers,
                        decl.name,
                        decl.typeParameters,
                        decl.interfaces,
                        decl.body,
                        decl.superclass);}
    throw new Error("Missing return statement in function");
  }

  final public UnmodifiedClassDef UnmodifiedClassDef() throws ParseException {
  UnmodifiedClassDef decl = new UnmodifiedClassDef();
  Word name;
    jj_consume_token(CLASS);
    name = Word();
                  decl.name = name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      decl.typeParameters = TypeParameters();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      decl.superclass = ClassOrInterfaceType();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      jj_consume_token(IMPLEMENTS);
      decl.interfaces = NameList();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      break;
    default:
      jj_la1[14] = jj_gen;
      _ignoreChar('{');
    }
    decl.body = BracedBody();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACE:
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[15] = jj_gen;
      _ignoreChar('}');
    }
    {if (true) return decl;}
    throw new Error("Missing return statement in function");
  }

  final public InnerClassDef InnerClassDef() throws ParseException {
  ModifiersAndVisibility modifiers;
  UnmodifiedClassDef decl;
  Token first = getToken(1);
    modifiers = ModifiersAndVisibility();
    decl = UnmodifiedClassDef();
    {if (true) return new InnerClassDef(_loc(first),
                             modifiers,
                             decl.name,
                             decl.typeParameters,
                             decl.interfaces,
                             decl.body,
                             decl.superclass);}
    throw new Error("Missing return statement in function");
  }

//  <CLASS>
//    
//    name = Word()
//    [ typeParams = TypeParameters() ]
//
//    [ <EXTENDS> superClass = ClassOrInterfaceType() ]
//    
//    [ <IMPLEMENTS> interfaces = NameList() ]
//
//  body = BracedBody() {
//    return new ClassDef(_loc(first),
//                                modifiers,
//                                name,
//                                typeParams,
//                                superClass,
//                                interfaces,
//                                body);
//  }
//}
  final public InterfaceDef InterfaceDef() throws ParseException {
  ModifiersAndVisibility modifiers;
  UnmodifiedInterfaceDef decl;
  Token first = getToken(1);
  _inInterface = true;
    modifiers = ModifiersAndVisibility();
    decl = UnmodifiedInterfaceDef();
    // parse the modifiers later
//    if ((mav.isStatic) ||
//        (mav.visibility == Visibility.PRIVATE) ||
//        (mav.visibility == Visibility.PROTECTED) ||
//        (mav.modifier == ClassModifier.FINAL))
//    {
//      throw new RuntimeException("invalid modifiers for top-level interface");
//    }

    {if (true) return new InterfaceDef(_loc(first),
                            modifiers,
                            decl.name,
                            decl.typeParameters,
                            decl.superinterfaces,
                            decl.body);}
    throw new Error("Missing return statement in function");
  }

  final public UnmodifiedInterfaceDef UnmodifiedInterfaceDef() throws ParseException {
  UnmodifiedInterfaceDef decl = new UnmodifiedInterfaceDef();
//  LinkedList methodList = new LinkedList();
//  LinkedList fieldList = new LinkedList();
//  LinkedList innerList = new LinkedList();
  BracedBody body;
  Word name;
    jj_consume_token(INTERFACE);
    name = Word();
                  decl.name = name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      decl.typeParameters = TypeParameters();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      decl.superinterfaces = NameList();
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      break;
    default:
      jj_la1[18] = jj_gen;
      _ignoreChar('{');
    }
    body = BracedBody();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACE:
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[19] = jj_gen;
      _ignoreChar('}');
    }
//    decl.methods = (AbstractMethodDef[]) methodList.toArray(new AbstractMethodDef[0]);
//    decl.fields = (FinalStaticFieldDef[]) fieldList.toArray(new FinalStaticFieldDef[0]);
//    decl.inners = (StaticInnerDefI[]) innerList.toArray(new StaticInnerDefI[0]);
    decl.body = body;
    {if (true) return decl;}
    throw new Error("Missing return statement in function");
  }

  final public InnerInterfaceDef InnerInterfaceDef() throws ParseException {
  ModifiersAndVisibility modifiers;
  UnmodifiedInterfaceDef decl;
  Token first = getToken(1);
  boolean oldInInterface = _inInterface;
  _inInterface = true;
    modifiers = ModifiersAndVisibility();
    decl = UnmodifiedInterfaceDef();
    _inInterface = oldInInterface;
    {if (true) return new InnerInterfaceDef(_loc(first),
                            modifiers,
                            decl.name,
                            decl.typeParameters,
                            decl.superinterfaces,
                            decl.body);}
    throw new Error("Missing return statement in function");
  }

// Represents the bodies of classes, interfaces, and methods.
  final public BracedBody BracedBody() throws ParseException {
  LinkedList<BodyItemI> items = new LinkedList<BodyItemI>();
  BodyItemI temp;
  Token first = getToken(1);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case NEW:
      case NULL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case RETURN:
      case SHORT:
      case STRICTFP:
      case STATIC:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRANSIENT:
      case TRUE:
      case TRY:
      case VOID:
      case VOLATILE:
      case WHILE:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case LBRACKET:
      case SEMICOLON:
      case ASSIGN:
      case GT:
      case LT:
      case BANG:
      case TILDE:
      case EQ:
      case LE:
      case GE:
      case NE:
      case SC_OR:
      case SC_AND:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case BIT_AND:
      case BIT_OR:
      case XOR:
      case REM:
      case LSHIFT:
      case RSSHIFT1:
      case RUSHIFT1:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case LSHIFTASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_4;
      }
      try {
        temp = BodyItem();
           items.addLast(temp);
      } catch (ParseException e) {
       break;
      }
    }
    SourceInfo si;
    if (items.size() == 0) {
      si = _loc(token);
    }
    else {
      si = _loc(first);
    }
    {if (true) return new BracedBody(si, items.toArray(new BodyItemI[0]));}
    throw new Error("Missing return statement in function");
  }

// A BodyItem is a method declaration, field declaration, statments, initializer, constructor, or inner declaration.
  final public BodyItemI BodyItem() throws ParseException {
  BodyItemI temp;
    try {
      if (jj_2_6(2147483647)) {
        temp = InnerClassDef();
      } else if (jj_2_7(2147483647)) {
        temp = InnerInterfaceDef();
      } else if (jj_2_8(2)) {
        temp = Initializer();
      } else if (jj_2_9(2147483647)) {
        temp = MethodDef();
      } else if (jj_2_10(2147483647)) {
        temp = ConstructorDef();
      } else if (jj_2_11(2147483647)) {
        temp = VariableDeclaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_la1[21] = jj_gen;
          _errorString(";(");
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case FOR:
        case IF:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case DECIMAL_LITERAL:
        case HEX_LITERAL:
        case OCTAL_LITERAL:
        case LONG_DECIMAL_LITERAL:
        case LONG_HEX_LITERAL:
        case LONG_OCTAL_LITERAL:
        case DOUBLE_FLOATING_POINT_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case LBRACKET:
        case SEMICOLON:
        case ASSIGN:
        case GT:
        case LT:
        case BANG:
        case TILDE:
        case EQ:
        case LE:
        case GE:
        case NE:
        case SC_OR:
        case SC_AND:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case BIT_AND:
        case BIT_OR:
        case XOR:
        case REM:
        case LSHIFT:
        case RSSHIFT1:
        case RUSHIFT1:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:
          temp = Statement();
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      {if (true) return temp;}
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a class body!");
    }
    throw new Error("Missing return statement in function");
  }

  final public MethodDef MethodDef() throws ParseException {
  Token first = getToken(1);
  ModifiersAndVisibility modifiers;
  TypeParameter[] typeParams = new TypeParameter[0];
  ReturnTypeI returnType;
  Word name;
  FormalParameter[] params;
  ReferenceType[] throwsArray = new ReferenceType[0];
  BracedBody body;
    try {
      modifiers = ModifiersAndVisibility();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        typeParams = TypeParameters();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      returnType = ReturnType();
      name = Word();
      params = FormalParameters();
      label_5:
      while (true) {
        if (jj_2_12(2147483647)) {
          ;
        } else {
          break label_5;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
      if (returnType instanceof Type) {
        returnType = new ArrayType(_loc(returnType), ((Type)returnType).getName() + "[]", (Type) returnType);
      }
      else { // void return
        _throwParseException("Cannot have method return array if base type is void!");
      }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        throwsArray = NameList();
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      if (!_isAbstract(modifiers) && !_inInterface) {
      body = ConcreteMethodBody();
      {if (true) return new ConcreteMethodDef(_loc(first),
                                   modifiers,
                                   typeParams,
                                   returnType,
                                   name,
                                   params,
                                   throwsArray,
                                   body);}
    }
    else {
      AbstractMethodBody();
      {if (true) return new AbstractMethodDef(_loc(first),
                                   modifiers,
                                   typeParams,
                                   returnType,
                                   name,
                                   params,
                                   throwsArray);}
    }
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a method declaration!");
    }
    throw new Error("Missing return statement in function");
  }

  final public BracedBody ConcreteMethodBody() throws ParseException {
  BracedBody body;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      break;
    default:
      jj_la1[25] = jj_gen;
      _errorChar('{');
    }
    body = BracedBody();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACE:
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[26] = jj_gen;
      _errorChar('}');
    }
    {if (true) return body;}
    throw new Error("Missing return statement in function");
  }

  final public void AbstractMethodBody() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[27] = jj_gen;
      _errorChar(';');
    }
  }

  final public VariableDeclaration VariableDeclaration() throws ParseException {
  ModifiersAndVisibility modifiers;
  LinkedList<VariableDeclarator> variableDeclarators;
//  Type type;
//  Word name;
//  VariableInitializerI initializer;
  Token first = getToken(1);
    try {
      modifiers = ModifiersAndVisibility();
      variableDeclarators = VariableDeclaratorList();
      {if (true) return new VariableDeclaration(_loc(first),
                                     modifiers,
                                     variableDeclarators.toArray(new VariableDeclarator[0]));}
    } catch (ParseException pe) {
    _throwParseException(pe, "This is not a valid variable declaration!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ReferenceType[] NameList() throws ParseException {
  LinkedList<ReferenceType> list = new LinkedList<ReferenceType>();
  ReferenceType temp;
    temp = ClassOrInterfaceType();
                                  list.add(temp);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      temp = ClassOrInterfaceType();
                                    list.add(temp);
    }
    {if (true) return list.toArray(new ReferenceType[0]);}
    throw new Error("Missing return statement in function");
  }

  final public ReturnTypeI ReturnType() throws ParseException {
  ReturnTypeI ret;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      jj_consume_token(VOID);
             ret = new VoidReturn(_loc(first), "void");
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      ret = Type();
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

//FormalParameterList FormalParameterList() :
//{
//  Object temp;
//  Token first = getToken(1);
//  LinkedList params = new LinkedList();
//}
//{
//  (<LPAREN> | _errorChar('('))
//  ( <RPAREN> { return new FormalParameterList(_loc(first), (FormalParameter[])params.toArray(new FormalParameter[0])); }
//  |
//  temp = FormalParameter() {
//    params.addLast(temp);
//  }
//   (<COMMA>
//    temp = FormalParameter() {
//     params.addLast(temp);
//   })*
//   (<RPAREN> | _errorChar(')')) { return new FormalParameterList(_loc(first), (FormalParameter[])params.toArray(new FormalParameter[0])); }
//   )
//}
  final public FormalParameter[] FormalParameters() throws ParseException {
  LinkedList<FormalParameter> list = new LinkedList<FormalParameter>();
  FormalParameter temp;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[30] = jj_gen;
      _errorChar('(');
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      temp = FormalParameter();
                               list.add(temp);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        temp = FormalParameter();
                                 list.add(temp);
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[33] = jj_gen;
      _errorString("),");
    }
    {if (true) return list.toArray(new FormalParameter[0]);}
    throw new Error("Missing return statement in function");
  }

  final public FormalParameter FormalParameter() throws ParseException {
  boolean isFinal = false;
  Type type;
  VariableDeclarator declarator;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINAL:
      jj_consume_token(FINAL);
              isFinal = true;
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    type = Type();
    declarator = VariableDeclarator(type);
    if (declarator instanceof InitializedVariableDeclarator) {
      _throwParseException("Cannot assign values to parameters!");
    }
    {if (true) return new FormalParameter(_loc(first), declarator, isFinal);}
    throw new Error("Missing return statement in function");
  }

  final public ConstructorDef ConstructorDef() throws ParseException {
  ModifiersAndVisibility visibility;
  Token name = null;
  FormalParameter[] formalParameters;
  ReferenceType[] throwsArray = new ReferenceType[0];
  BracedBody code;
  Token first = getToken(1);

  // null will indicate that there is none
  ConstructorInvocation invocation = null;
    try {
      visibility = ModifiersAndVisibility();
      //      (name = <IDENTIFIER> | _errorString("identifier"))
            name = jj_consume_token(IDENTIFIER);
      formalParameters = FormalParameters();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        throwsArray = NameList();
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        jj_consume_token(LBRACE);
        break;
      default:
        jj_la1[36] = jj_gen;
        _errorChar('{');
      }
      if (jj_2_13(2147483647)) {
        invocation = ExplicitConstructorInvocation();
      } else {
        ;
      }
      code = BracedBody();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RBRACE:
        jj_consume_token(RBRACE);
        break;
      default:
        jj_la1[37] = jj_gen;
        _errorChar('}');
      }
      ConstructorBody body;
      if (invocation == null) {
        body = new NormalConstructorBody(_loc(code), code);
      }
      else {
        body = new ConstructorBodyWithExplicitConstructorInvocation(_loc(code), code, invocation);
      }

      {if (true) return new ConstructorDef(_loc(first),
                                name.image,
                                visibility,
                                formalParameters,
                                throwsArray,
                                body);}
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a constructor definition!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ConstructorInvocation ExplicitConstructorInvocation() throws ParseException {
  Token first = getToken(1);
  Expression[] arguments;

  // null means no qualifier for super.
  Expression qualifier = null;
    if (jj_2_15(2147483647)) {
      jj_consume_token(THIS);
      arguments = Arguments();
      jj_consume_token(SEMICOLON);
    {if (true) return new ThisConstructorInvocation(_loc(first), arguments);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACKET:
      case ASSIGN:
      case GT:
      case LT:
      case BANG:
      case TILDE:
      case EQ:
      case LE:
      case GE:
      case NE:
      case SC_OR:
      case SC_AND:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case BIT_AND:
      case BIT_OR:
      case XOR:
      case REM:
      case LSHIFT:
      case RSSHIFT1:
      case RUSHIFT1:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case LSHIFTASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:
        if (jj_2_14(2147483647)) {
          qualifier = Expression(";");
          jj_consume_token(DOT);
        } else {
          ;
        }
        jj_consume_token(SUPER);
        arguments = Arguments();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_la1[38] = jj_gen;
          _errorChar('l');
        }
    if (qualifier == null) {
      {if (true) return new UnqualifiedSuperConstructorInvocation(_loc(first), arguments);}
    }
    else {
      {if (true) return new QualifiedSuperConstructorInvocation(_loc(first), arguments, qualifier);}
    }
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Initializer Initializer() throws ParseException {
  boolean isStatic = false;
  Block code;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      jj_consume_token(STATIC);
               isStatic = true;
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    code = Block();
    if (isStatic) {
      {if (true) return new StaticInitializer(_loc(first), code);}
    }
    else {
      {if (true) return new InstanceInitializer(_loc(first), code);}
    }
    throw new Error("Missing return statement in function");
  }

/*
 * Type, name and expression syntax follows.
 */
  final public Type Type() throws ParseException {
  Type type;
  Token first = getToken(1);
    if (jj_2_16(3)) {
      type = PrimitiveType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        type = ReferenceType();
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_8:
    while (true) {
      if (jj_2_17(2147483647)) {
        ;
      } else {
        break label_8;
      }
      jj_consume_token(LBRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RBRACKET:
        jj_consume_token(RBRACKET);
        break;
      default:
        jj_la1[42] = jj_gen;
        _errorChar(']');
      }
      type = new ArrayType(_loc(first), type.getName() + "[]", type);
    }
    {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public PrimitiveType PrimitiveType() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
      name = jj_consume_token(BOOLEAN);
      break;
    case CHAR:
      name = jj_consume_token(CHAR);
      break;
    case BYTE:
      name = jj_consume_token(BYTE);
      break;
    case SHORT:
      name = jj_consume_token(SHORT);
      break;
    case INT:
      name = jj_consume_token(INT);
      break;
    case LONG:
      name = jj_consume_token(LONG);
      break;
    case FLOAT:
      name = jj_consume_token(FLOAT);
      break;
    case DOUBLE:
      name = jj_consume_token(DOUBLE);
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new PrimitiveType(_loc(name), name.image);}
    throw new Error("Missing return statement in function");
  }

  final public ReferenceType ReferenceType() throws ParseException {
  ReferenceType type;
    if (jj_2_18(2)) {
      type = ClassOrInterfaceType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        type = TypeVariable();
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayType ArrayType() throws ParseException {
  Type elemType;
  ArrayType arrayType = null;
  Token first = getToken(1);
    if (jj_2_19(2)) {
      elemType = PrimitiveType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        elemType = ReferenceType();
        break;
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_9:
    while (true) {
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
      if (arrayType == null) {
        arrayType = new ArrayType(_loc(first), elemType.getName() + "[]", elemType);
      }
      else {
        arrayType = new ArrayType(_loc(first), arrayType.getName() + "[]", arrayType);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_9;
      }
    }
    {if (true) return arrayType;}
    throw new Error("Missing return statement in function");
  }

  final public TypeVariable TypeVariable() throws ParseException {
  Token name;
    name = jj_consume_token(IDENTIFIER);
    {if (true) return new TypeVariable(_loc(name), name.image);}
    throw new Error("Missing return statement in function");
  }

/** have to break out each period inside the name. */
  final public ReferenceType ClassOrInterfaceType() throws ParseException {
  Type[] typeArguments = new Type[0];
  Token identToken;
  ReferenceType type;
    identToken = jj_consume_token(IDENTIFIER);
    if (jj_2_20(2147483647)) {
      typeArguments = TypeArguments();
    } else {
      ;
    }
    type = new ClassOrInterfaceType(_loc(identToken), identToken.image, typeArguments);
    typeArguments = new Type[0];
    label_10:
    while (true) {
      if (jj_2_21(2)) {
        ;
      } else {
        break label_10;
      }
      jj_consume_token(DOT);
      identToken = jj_consume_token(IDENTIFIER);
      if (jj_2_22(2147483647)) {
        typeArguments = TypeArguments();
      } else {
        ;
      }
      ClassOrInterfaceType right = new ClassOrInterfaceType(_loc(identToken), identToken.image, typeArguments);
      typeArguments = new Type[0];
      type = new MemberType(_loc(type), type.getName() + "." + right.getName(), type, right);
    }
    {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public Type[] TypeArguments() throws ParseException {
  LinkedList<Type> list = new LinkedList<Type>();
  Type temp;
    jj_consume_token(LT);
    if (jj_2_23(2147483647)) {
      temp = ArrayType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        temp = ReferenceType();
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    list.add(temp);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
      case COMMA:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      if (jj_2_24(2147483647)) {
        temp = ArrayType();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          temp = ReferenceType();
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      list.add(temp);
    }
    RightAngledBracket();
    {if (true) return list.toArray(new Type[0]);}
    throw new Error("Missing return statement in function");
  }

  final public TypeParameter[] TypeParameters() throws ParseException {
  LinkedList<TypeParameter> list = new LinkedList<TypeParameter>();
  TypeParameter temp;
    jj_consume_token(LT);
    temp = TypeFormalParameter();
                                list.add(temp);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case COMMA:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      temp = TypeFormalParameter();
                                   list.add(temp);
    }
    RightAngledBracket();
    {if (true) return list.toArray(new TypeParameter[0]);}
    throw new Error("Missing return statement in function");
  }

  final public Token RightAngledBracket() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GT:
      t = jj_consume_token(GT);
      break;
    case RSSHIFT1:
      t = jj_consume_token(RSSHIFT1);
      break;
    case RSSHIFT2:
      t = jj_consume_token(RSSHIFT2);
      break;
    case RUSHIFT1:
      t = jj_consume_token(RUSHIFT1);
      break;
    case RUSHIFT2:
      t = jj_consume_token(RUSHIFT2);
      break;
    case RUSHIFT3:
      t = jj_consume_token(RUSHIFT3);
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public TypeParameter TypeFormalParameter() throws ParseException {
  TypeVariable variable;
  ReferenceType bound = NO_TYPE;
  Token first = getToken(1);
    variable = TypeVariable();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      bound = ClassOrInterfaceType();
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    {if (true) return new TypeParameter(_loc(first), variable, bound);}
    throw new Error("Missing return statement in function");
  }

  final public Literal IntegerLiteral(boolean isNegative, Token first) throws ParseException {
  Token token;

  // we have to use biginteger to deal with literals that intentionally overflow
  // 0xfffffffffffffffe is an example, from ACParserTokenManager.java.
  // Also this allows us to deal with Integer/Long.MIN_VALUE
  BigInteger value;
  int maxBitLength;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        token = jj_consume_token(DECIMAL_LITERAL);
        value = new BigInteger(token.image, 10);
        maxBitLength = 31;
        break;
      case OCTAL_LITERAL:
        token = jj_consume_token(OCTAL_LITERAL);
        value = new BigInteger(token.image, 8);
        maxBitLength = 32; // it's always positive so use of sign bit ok

        break;
      case HEX_LITERAL:
        token = jj_consume_token(HEX_LITERAL);
        value = new BigInteger(token.image.substring(2), 16);
        maxBitLength = 32; // it's always positive so use of sign bit ok

        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (isNegative) {
        value = value.negate();
      }

      if (value.bitLength() <= maxBitLength) {
        {if (true) return new IntegerLiteral(_loc(first), value.intValue());}
      }
      else {
        {if (true) throw new RuntimeException("Integer literal too big: " + token.image);}
      }
      break;
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LONG_DECIMAL_LITERAL:
        token = jj_consume_token(LONG_DECIMAL_LITERAL);
        value = new BigInteger(_stripL(token.image), 10);
        maxBitLength = 63;
        break;
      case LONG_OCTAL_LITERAL:
        token = jj_consume_token(LONG_OCTAL_LITERAL);
        value = new BigInteger(_stripL(token.image), 8);
        maxBitLength = 64; // it's always positive so use of sign bit ok

        break;
      case LONG_HEX_LITERAL:
        token = jj_consume_token(LONG_HEX_LITERAL);
        value = new BigInteger(_stripL(token.image.substring(2)), 16);
        maxBitLength = 64; // it's always positive so use of sign bit ok

        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (isNegative) {
        value = value.negate();
      }

      if (value.bitLength() <= maxBitLength) {
        {if (true) return new LongLiteral(_loc(first), value.longValue());}
      }
      else {
        {if (true) throw new RuntimeException("Long literal too big: " + token.image);}
      }
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Literal FloatLiteral() throws ParseException {
  Token t;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLE_FLOATING_POINT_LITERAL:
      t = jj_consume_token(DOUBLE_FLOATING_POINT_LITERAL);
      try {
        double value = Double.parseDouble(t.image);
        {if (true) return new DoubleLiteral(_loc(first), value);}
      }
      catch (NumberFormatException e) {
        {if (true) throw new RuntimeException("Invalid double constant: " + t.image + ". Exception: " + e);}
      }
      break;
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
      try {
        float value = Float.parseFloat(t.image);
        {if (true) return new FloatLiteral(_loc(first), value);}
      }
      catch (NumberFormatException e) {
        {if (true) throw new RuntimeException("Invalid float constant: " + t.image + ". Exception: " + e);}
      }
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public BooleanLiteral BooleanLiteral() throws ParseException {
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
          {if (true) return new BooleanLiteral(_loc(first), true);}
      break;
    case FALSE:
      jj_consume_token(FALSE);
            {if (true) return new BooleanLiteral(_loc(first), false);}
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public StringLiteral StringLiteral() throws ParseException {
  Token text;
  Token first = getToken(1);
    text = jj_consume_token(STRING_LITERAL);
    {if (true) return new StringLiteral(_loc(first), CharConverter.unescapeString(_stripQuotes(text.image)));}
    throw new Error("Missing return statement in function");
  }

  final public ThisLiteral ThisLiteral() throws ParseException {
  Token first = getToken(1);
    jj_consume_token(THIS);
    {if (true) return new ThisLiteral(_loc(first));}
    throw new Error("Missing return statement in function");
  }

  final public SuperLiteral SuperLiteral() throws ParseException {
  Token first = getToken(1);
    jj_consume_token(SUPER);
    {if (true) return new SuperLiteral(_loc(first));}
    throw new Error("Missing return statement in function");
  }

  final public ClassLiteral ClassLiteral() throws ParseException {
  Token first = getToken(1);
    jj_consume_token(CLASS);
    {if (true) return new ClassLiteral(_loc(first));}
    throw new Error("Missing return statement in function");
  }

  final public Word Word() throws ParseException {
  Token text;
  Token first = getToken(1);
    text = jj_consume_token(IDENTIFIER);
    {if (true) return new Word(_loc(first), text.image);}
    throw new Error("Missing return statement in function");
  }

//IntegerLiteral IntegerLiteral() :
//{
//  Token s;
//  Token first = getToken(1);
//}
//{
//  s = <INTEGER_LITERAL> {
//    int i = Integer.parseInt(s.image);
//    return new IntegerLiteral(_loc(first), i);
//  }
//}
//
//FloatLiteral FloatLiteral() :
//{
//  Token s;
//  Token first = getToken(1);
//}
//{
//  s = <FLOATING_POINT_LITERAL> {
//    double d = Double.parseDouble(s.image);
//    return new FloatLiteral(_loc(first), d);
//  }
//}

//CharacterLiteral CharacterLiteral() :
//{
//  Token s;
//  Token first = getToken(1);
//}
//{
//  s = <CHARACTER_LITERAL> {
//    // Char is quoted so the real character is in the middle
//    return new CharacterLiteral(_loc(first), CharConverter.unescapeChar(_stripQuotes(s.image)));
//  }
//}
  final public Operator Operator() throws ParseException {
  Token kind;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      kind = jj_consume_token(ASSIGN);
      break;
    case GT:
      kind = jj_consume_token(GT);
      break;
    case LT:
      kind = jj_consume_token(LT);
      break;
    case BANG:
      kind = jj_consume_token(BANG);
      break;
    case TILDE:
      kind = jj_consume_token(TILDE);
      break;
    case EQ:
      //   kind = <HOOK> |
      //   kind = <COLON> |
         kind = jj_consume_token(EQ);
      break;
    case LE:
      kind = jj_consume_token(LE);
      break;
    case GE:
      kind = jj_consume_token(GE);
      break;
    case NE:
      kind = jj_consume_token(NE);
      break;
    case SC_OR:
      kind = jj_consume_token(SC_OR);
      break;
    case SC_AND:
      kind = jj_consume_token(SC_AND);
      break;
    case INCR:
      kind = jj_consume_token(INCR);
      break;
    case DECR:
      kind = jj_consume_token(DECR);
      break;
    case PLUS:
      kind = jj_consume_token(PLUS);
      break;
    case MINUS:
      kind = jj_consume_token(MINUS);
      break;
    case STAR:
      kind = jj_consume_token(STAR);
      break;
    case SLASH:
      kind = jj_consume_token(SLASH);
      break;
    case BIT_AND:
      kind = jj_consume_token(BIT_AND);
      break;
    case BIT_OR:
      kind = jj_consume_token(BIT_OR);
      break;
    case XOR:
      kind = jj_consume_token(XOR);
      break;
    case REM:
      kind = jj_consume_token(REM);
      break;
    case LSHIFT:
      kind = jj_consume_token(LSHIFT);
      break;
    case PLUSASSIGN:
      kind = jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      kind = jj_consume_token(MINUSASSIGN);
      break;
    case STARASSIGN:
      kind = jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      kind = jj_consume_token(SLASHASSIGN);
      break;
    case ANDASSIGN:
      kind = jj_consume_token(ANDASSIGN);
      break;
    case ORASSIGN:
      kind = jj_consume_token(ORASSIGN);
      break;
    case XORASSIGN:
      kind = jj_consume_token(XORASSIGN);
      break;
    case REMASSIGN:
      kind = jj_consume_token(REMASSIGN);
      break;
    case LSHIFTASSIGN:
      kind = jj_consume_token(LSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGN:
      kind = jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      kind = jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    case RSSHIFT1:
    case RUSHIFT1:
      kind = RightShiftOp();
      break;
    default:
      jj_la1[60] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Operator(_loc(first), kind.image);}
    throw new Error("Missing return statement in function");
  }

  final public Token RightShiftOp() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RSSHIFT1:
      t = jj_consume_token(RSSHIFT1);
      jj_consume_token(RSSHIFT2);
   {if (true) return t;}
      break;
    case RUSHIFT1:
      t = jj_consume_token(RUSHIFT1);
      jj_consume_token(RUSHIFT2);
      jj_consume_token(RUSHIFT3);
  {if (true) return t;}
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * This is the construct representing all bracketed expressions
 * within an OtherExpression.  As far as we can tell, this only
 * applies to an array reference, so there can only be one
 * expression within the brackets.
 */
  final public Bracketed Bracketed() throws ParseException {
  Expression expr;
  Token first = getToken(1);
    jj_consume_token(LBRACKET);
    expr = Expression("]");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACKET:
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[62] = jj_gen;
      _errorChar(']');
    }
    {if (true) return new Bracketed(_loc(first), expr);}
    throw new Error("Missing return statement in function");
  }

/**
 * This is the construct representing all braced expressions
 * within an OtherExpression.  Not sure right now what this
 * applies to.  If there can be multiple Expression within
 * braces in an OtherExpression, then put the delimiter in
 * the string passed to Expression() and parse it out as well.
 * - Not used for now since it can't appear in an OtherExpression.
 */
//Braced Braced() :
//{
//  Expression expr;
//  Token first = getToken(1);
//}
//{
//  try {
//    <LBRACE>
//      (
//       temp = Expression("}") {
//      contents.addLast(temp);
//    }
//    )/* * */
//      
//      ( <RBRACE> {
//      return new Braced(_loc(first), (Expression[])contents.toArray(new Expression[0]));
//    } |
//       <EOF> {
//      //    throw generateParseException();
//      _throwParseException("Missing '}'!");
//    })
//  }
//  catch (ParseException pe) {
//    _throwParseException(pe, "This cannot appear within braces!");
//  }
//}

/**
 * This is the construct representing all parenthesized expressions
 * within an OtherExpression.  Not sure right now what this
 * applies to.  If there can be multiple Expression within
 * braces in an OtherExpression, then put the delimiter in
 * the string passed to Expression() and parse it out as well.
 * Note that method invocations are not OtherExpressions, so
 * we don't think there can be multiple expressions.
 */
  final public Parenthesized Parenthesized() throws ParseException {
  Expression expr;
  Token first = getToken(1);
    jj_consume_token(LPAREN);
    expr = Expression(")");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[63] = jj_gen;
      _errorChar(')');
    }
    {if (true) return new Parenthesized(_loc(first), expr);}
    throw new Error("Missing return statement in function");
  }

//// I suppose this can be in either parens or braces so it has to be general
//CommaSeparatedList CommaSeparatedList() :
//{    
//  LinkedList contents = new LinkedList();  
//  Object temp;
//  Token first = getToken(1);
//}
//{  
//  temp = JExpression() { contents.add(temp); }
//  (
//    <COMMA>
//    temp = JExpression() { contents.add(temp); }
//  )* {
//    return new CommaSeparatedList(_loc(first), (JExpression[])contents.toArray(new JExpression[0]));
//  }
//}

//SemicolonSeparatedList SemicolonSeparatedList() :
//{    
//  LinkedList contents = new LinkedList();  
//  Object temp;
//  Token first = getToken(1);
//}
//{  
//  temp = JExpression() { contents.add(temp); }
//  (
//    <SEMICOLON>
//    temp = JExpression() { contents.add(temp); }
//  )* {
//    return new SemicolonSeparatedList(_loc(first), (JExpression[])contents.toArray(new JExpression[0]));
//  }
//}
  final public CompoundWord CompoundWord() throws ParseException {
  LinkedList<Word> contents = new LinkedList<Word>();
  Word temp;
  Token first = getToken(1);
    temp = Word();
                  contents.add(temp);
    label_13:
    while (true) {
      if (jj_2_25(2147483647)) {
        ;
      } else {
        break label_13;
      }
      jj_consume_token(DOT);
      temp = Word();
                    contents.add(temp);
    }
    {if (true) return new CompoundWord(_loc(first), contents.toArray(new Word[0]));}
    throw new Error("Missing return statement in function");
  }

//LineCommented LineCommented() :
//{
//  StringBuffer contents = new StringBuffer();
//  Token first = getToken(1);
//}
//{




/*
 * Statement syntax follows.
 */
  final public Statement Statement() throws ParseException {
  Statement temp;
    try {
      if (jj_2_26(2147483647)) {
        temp = Block();
      } else if (jj_2_27(2)) {
        temp = LabeledStatement();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          temp = EmptyStatement();
          break;
        case SWITCH:
          temp = SwitchStatement();
          break;
        case IF:
          temp = IfStatement();
          break;
        case WHILE:
          temp = WhileStatement();
          break;
        case DO:
          temp = DoStatement();
          break;
        case FOR:
          temp = ForStatement();
          break;
        case BREAK:
          temp = BreakStatement();
          break;
        case CONTINUE:
          temp = ContinueStatement();
          break;
        case RETURN:
          temp = ReturnStatement();
          break;
        case THROW:
          temp = ThrowStatement();
          break;
        case SYNCHRONIZED:
          temp = SynchronizedStatement();
          break;
        case TRY:
          temp = TryStatement();
          break;
        default:
          jj_la1[64] = jj_gen;
          if (jj_2_28(2147483647)) {
            temp = StatementExpression();
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    {if (true) return temp;}
    } catch (ParseException pe) {
    _throwParseException(pe, "Invalid statement.");
    }
    throw new Error("Missing return statement in function");
  }

  final public LabeledStatement LabeledStatement() throws ParseException {
  Token label;
  Statement statement;
    label = jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    statement = Statement();
    {if (true) return new LabeledStatement(_loc(label), label.image, statement);}
    throw new Error("Missing return statement in function");
  }

//BlockStatementI[] BlockStatements() :
//{
//  LinkedList list = new LinkedList();
//}
//{
//  ( BlockStatement(list) )*
//
//  { return (BlockStatementI[]) list.toArray(new BlockStatementI[0]); }
//}
  final public Block Block() throws ParseException {
  BracedBody code;
  Token first = getToken(1);
    jj_consume_token(LBRACE);
    code = BracedBody();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACE:
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[65] = jj_gen;
      _errorChar('}');
    }
    {if (true) return new Block(_loc(first), code);}
    throw new Error("Missing return statement in function");
  }

//void BlockStatement(LinkedList statementList) :
//{
//  BlockStatementI temp;
//  UnmodifiedClassDef decl;
//  boolean isStrictfp = false;
//  Token first = getToken(1);
//}
//{
//  (
//    LOOKAHEAD([ <FINAL> ] Type() <IDENTIFIER>)
//     temp = VariableDeclaration() <SEMICOLON>
//  |
//    temp = Statement() { statementList.add(temp); }
//  |
//    [ <STRICTFP> { isStrictfp = true; } ]
//    decl = UnmodifiedClassDef()
//    {
//      temp = new LocalClassDef(_loc(first),
//                               decl.name,
//                               ClassModifier.NONE,
//                               decl.typeParameters,
//                               isStrictfp,
//                               decl.superclass,
//                               decl.interfaces,
//                               decl.body);
////                               decl.body.constructors,
////                               decl.body.methods,
////                               decl.body.fields,
////                               decl.body.initializers,
////                               decl.body.inners);
//      statementList.add(temp);
//    }
//  )
//}

// pass in the list because we can make multiple variable declarations!
// TODO: This sets location of all variables declared at once to be the entire line!
// This is combined into the VariableDeclaration construct.
//void LocalVariableDeclaration(LinkedList statementList) :
//{
//  boolean isFinal = false;
//  LinkedList<VariableDeclarator> variableList;
//  Token first = getToken(1);
//}
//{
//  [ <FINAL> { isFinal = true; } ]
//  variableList = VariableDeclaratorList()
//  {
//    SourceInfo info = _loc(first);
//
//    ListIterator itor = variableList.listIterator();
//    while (itor.hasNext()) {
//      VariableDeclarator decl = (VariableDeclarator) itor.next();
//
//      statementList.add(new LocalVariableDeclaration(info, decl.type, decl.identifier, decl.initializer, isFinal));
//    }
//  }
//}
  final public EmptyStatement EmptyStatement() throws ParseException {
  Token first = getToken(1);
    jj_consume_token(SEMICOLON);
    {if (true) return new EmptyStatement(_loc(first));}
    throw new Error("Missing return statement in function");
  }

  final public StatementExpression StatementExpression() throws ParseException {
  Expression exp;
//  LinkedList exprPieceList = new LinkedList();
  ExpressionPiece[] pieces;
  ExpressionPiece[] piecesWithNoOtherExpressions;
  ExpressionPiece lastPiece;
  Token first = getToken(1);
  boolean foundAssignment;
    try {
      exp = Expression(";");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[66] = jj_gen;
        _errorChar(';');
      }
      /* The rest of the method checks that the statement expression is really a statement instead of an expression like 1+1;
       * This process involves checking for assignment operators.  If one is found in the expression, it is permitted.  The
       * expression is also accepted if it ends in a method invocation, allocation expression, or is a pre or post increment/
       * decrement operator.
       */
      pieces = exp.getPieces();
      piecesWithNoOtherExpressions = new ExpressionPiece[pieces.length];
      for (int i = 0; i < pieces.length; i++) {
        if (pieces[i] instanceof OtherExpression) {
          piecesWithNoOtherExpressions[i] = ((OtherExpression)pieces[i]).getExprPiece();
        }
        else {
          piecesWithNoOtherExpressions[i] = pieces[i];
        }
      }
      lastPiece = piecesWithNoOtherExpressions[pieces.length - 1];
      foundAssignment = false;
      for (int i = 0; i < piecesWithNoOtherExpressions.length; i++) {
        //System.out.println("KIND = " + pieces[i] + "instanceof Operator: " + (piecesWithNoOtherExpressions[i] instanceof Operator));
        if (piecesWithNoOtherExpressions[i] instanceof Operator && (((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("+=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("-=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("*=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("/=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("&=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("|=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("^=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("%=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("<<=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals(">>=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals(">>>="))) {
          foundAssignment = true;
          break;
        }
      }
      if (!(lastPiece instanceof MethodInvocationExpression) &&
          !(lastPiece instanceof AllocationExpression) &&
          !(piecesWithNoOtherExpressions[0] instanceof Operator && (((Operator)piecesWithNoOtherExpressions[0]).getKind().equals("++")
                                                || ((Operator)piecesWithNoOtherExpressions[0]).getKind().equals("--"))) &&
          !(lastPiece instanceof Operator && (((Operator)lastPiece).getKind().equals("++")
                                                || ((Operator)lastPiece).getKind().equals("--"))) &&
          !foundAssignment)
      {
        _throwParseException("This is not a statement.");
      }
      else {
        //      exp = new Expression(_loc(first), (ExpressionPiece[])exprPieceList.toArray(new ExpressionPiece[0]));
        {if (true) return new StatementExpression(_loc(first), exp);}
      }
    } catch (ParseException pe) {
    _throwParseException(pe, "<identifier> expected");
    }
    throw new Error("Missing return statement in function");
  }

  final public Statement SwitchStatement() throws ParseException {
  Expression test;
  SwitchCase tempCase;
  LinkedList<SwitchCase> caseList = new LinkedList<SwitchCase>();
  Token first = getToken(1);
    jj_consume_token(SWITCH);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[67] = jj_gen;
      _errorChar('(');
    }
    test = Expression(")");
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      break;
    default:
      jj_la1[68] = jj_gen;
      _errorChar('{');
    }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
      case _DEFAULT:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_14;
      }
      tempCase = SwitchCase();
      caseList.add(tempCase);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACE:
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[70] = jj_gen;
      _errorChar('}');
    }
    {if (true) return new SwitchStatement(_loc(first), test, caseList.toArray(new SwitchCase[0]));}
    throw new Error("Missing return statement in function");
  }

  final public SwitchCase SwitchCase() throws ParseException {
  BracedBody statements;
  Expression label;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE:
      jj_consume_token(CASE);
      label = Expression(":");
      jj_consume_token(COLON);
      statements = BracedBody();
    {if (true) return new LabeledCase(_loc(first), statements, label);}
      break;
    case _DEFAULT:
      jj_consume_token(_DEFAULT);
      jj_consume_token(COLON);
      statements = BracedBody();
    {if (true) return new DefaultCase(_loc(first), statements);}
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Statement IfStatement() throws ParseException {
  Expression testExpression;
  Statement thenStatement;
  Statement elseStatement = null;
  Token first = getToken(1);
    jj_consume_token(IF);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[72] = jj_gen;
      _errorChar('(');
    }
    testExpression = Expression(")");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[73] = jj_gen;
      _errorChar(')');
    }
    thenStatement = Statement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      elseStatement = Statement();
      break;
    default:
      jj_la1[74] = jj_gen;
      ;
    }
    if (elseStatement == null) {
      {if (true) return new IfThenStatement(_loc(first), testExpression, thenStatement);}
    }
    else {
      {if (true) return new IfThenElseStatement(_loc(first), testExpression, thenStatement, elseStatement);}
    }
    throw new Error("Missing return statement in function");
  }

  final public WhileStatement WhileStatement() throws ParseException {
  Expression condition;
  Statement body;
  Token first = getToken(1);
    jj_consume_token(WHILE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[75] = jj_gen;
      _errorChar('(');
    }
    condition = Expression(")");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[76] = jj_gen;
      _errorChar(')');
    }
    body = Statement();
    {if (true) return new WhileStatement(_loc(first), condition, body);}
    throw new Error("Missing return statement in function");
  }

  final public Statement DoStatement() throws ParseException {
  Expression condition;
  Statement body;
  Token first = getToken(1);
    jj_consume_token(DO);
    body = Statement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHILE:
      jj_consume_token(WHILE);
      break;
    default:
      jj_la1[77] = jj_gen;
      _errorString("\"while\"");
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[78] = jj_gen;
      _errorChar('(');
    }
    condition = Expression(")");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[79] = jj_gen;
      _errorChar(')');
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[80] = jj_gen;
      _errorChar(';');
    }
    {if (true) return new DoStatement(_loc(first), body, condition);}
    throw new Error("Missing return statement in function");
  }

  final public ForStatement ForStatement() throws ParseException {
  ForInitI init = EMPTY_FOR_INIT;
  ForConditionI condition = EMPTY_FOR_CONDITION;
  ForUpdateI update = EMPTY_FOR_UPDATE;
  Statement body; // can be a block
  Token first = getToken(1);
    jj_consume_token(FOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[81] = jj_gen;
      _errorChar('(');
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case NATIVE:
    case NEW:
    case NULL:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SHORT:
    case STRICTFP:
    case STATIC:
    case SUPER:
    case SYNCHRONIZED:
    case THIS:
    case TRANSIENT:
    case TRUE:
    case VOID:
    case VOLATILE:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:
    case DOUBLE_FLOATING_POINT_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACKET:
    case ASSIGN:
    case GT:
    case LT:
    case BANG:
    case TILDE:
    case EQ:
    case LE:
    case GE:
    case NE:
    case SC_OR:
    case SC_AND:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case STAR:
    case SLASH:
    case BIT_AND:
    case BIT_OR:
    case XOR:
    case REM:
    case LSHIFT:
    case RSSHIFT1:
    case RUSHIFT1:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:
      init = ForInit();
      break;
    default:
      jj_la1[82] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[83] = jj_gen;
      _errorChar(';');
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:
    case DOUBLE_FLOATING_POINT_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACKET:
    case ASSIGN:
    case GT:
    case LT:
    case BANG:
    case TILDE:
    case EQ:
    case LE:
    case GE:
    case NE:
    case SC_OR:
    case SC_AND:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case STAR:
    case SLASH:
    case BIT_AND:
    case BIT_OR:
    case XOR:
    case REM:
    case LSHIFT:
    case RSSHIFT1:
    case RUSHIFT1:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:
      condition = Expression(";");
      break;
    default:
      jj_la1[84] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[85] = jj_gen;
      _errorChar(';');
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:
    case DOUBLE_FLOATING_POINT_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACKET:
    case ASSIGN:
    case GT:
    case LT:
    case BANG:
    case TILDE:
    case EQ:
    case LE:
    case GE:
    case NE:
    case SC_OR:
    case SC_AND:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case STAR:
    case SLASH:
    case BIT_AND:
    case BIT_OR:
    case XOR:
    case REM:
    case LSHIFT:
    case RSSHIFT1:
    case RUSHIFT1:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:
      update = ForUpdate();
      break;
    default:
      jj_la1[86] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[87] = jj_gen;
      _errorChar(')');
    }
    body = Statement();
    {if (true) return new ForStatement(_loc(first), init, condition, update, body);}
    throw new Error("Missing return statement in function");
  }

  final public ForInitI ForInit() throws ParseException {
  ForInitI init;
    if (jj_2_29(2147483647)) {
      init = VariableDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACKET:
      case ASSIGN:
      case GT:
      case LT:
      case BANG:
      case TILDE:
      case EQ:
      case LE:
      case GE:
      case NE:
      case SC_OR:
      case SC_AND:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case BIT_AND:
      case BIT_OR:
      case XOR:
      case REM:
      case LSHIFT:
      case RSSHIFT1:
      case RUSHIFT1:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case LSHIFTASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:
        init = StatementExpressionList();
        break;
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return init;}
    throw new Error("Missing return statement in function");
  }

  final public ForUpdateI ForUpdate() throws ParseException {
  ForUpdateI temp;
    temp = StatementExpressionList();
    {if (true) return temp;}
    throw new Error("Missing return statement in function");
  }

  final public BreakStatement BreakStatement() throws ParseException {
  Token label = null;
  Token first = getToken(1);
    jj_consume_token(BREAK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      label = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[89] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[90] = jj_gen;
      _errorChar(';');
    }
    if (label == null) {
      {if (true) return new UnlabeledBreakStatement(_loc(first));}
    }
    else {
      {if (true) return new LabeledBreakStatement(_loc(first), label.image);}
    }
    throw new Error("Missing return statement in function");
  }

  final public ContinueStatement ContinueStatement() throws ParseException {
  Token label = null;
  Token first = getToken(1);
    jj_consume_token(CONTINUE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      label = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[91] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[92] = jj_gen;
      _errorChar(';');
    }
    if (label == null) {
      {if (true) return new UnlabeledContinueStatement(_loc(first));}
    }
    else {
      {if (true) return new LabeledContinueStatement(_loc(first), label.image);}
    }
    throw new Error("Missing return statement in function");
  }

  final public ReturnStatement ReturnStatement() throws ParseException {
  Expression value = null;
  Token first = getToken(1);
    jj_consume_token(RETURN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:
    case DOUBLE_FLOATING_POINT_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACKET:
    case ASSIGN:
    case GT:
    case LT:
    case BANG:
    case TILDE:
    case EQ:
    case LE:
    case GE:
    case NE:
    case SC_OR:
    case SC_AND:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case STAR:
    case SLASH:
    case BIT_AND:
    case BIT_OR:
    case XOR:
    case REM:
    case LSHIFT:
    case RSSHIFT1:
    case RUSHIFT1:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:
      value = Expression(";");
      break;
    default:
      jj_la1[93] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[94] = jj_gen;
      _errorChar(';');
    }
    if (value == null) {
      {if (true) return new VoidReturnStatement(_loc(first));}
    }
    else {
      {if (true) return new ValueReturnStatement(_loc(first), value);}
    }
    throw new Error("Missing return statement in function");
  }

  final public ThrowStatement ThrowStatement() throws ParseException {
  Expression exp;
  Token first = getToken(1);
    jj_consume_token(THROW);
    exp = Expression(";");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[95] = jj_gen;
      _errorChar(';');
    }
    {if (true) return new ThrowStatement(_loc(first), exp);}
    throw new Error("Missing return statement in function");
  }

  final public SynchronizedStatement SynchronizedStatement() throws ParseException {
  Expression exp;
  Block block;
  Token first = getToken(1);
    jj_consume_token(SYNCHRONIZED);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[96] = jj_gen;
      _errorChar('(');
    }
    exp = Expression(")");
    jj_consume_token(RPAREN);
    block = Block();
    {if (true) return new SynchronizedStatement(_loc(first), exp, block);}
    throw new Error("Missing return statement in function");
  }

  final public TryCatchStatement TryStatement() throws ParseException {
  Block tryBlock;
  LinkedList<CatchBlock> catchList = new LinkedList<CatchBlock>();
  FormalParameter catchParam;
  Block tempCatchBlock;
  Block finallyBlock = null;
  Token first = getToken(1);
    jj_consume_token(TRY);
    tryBlock = Block();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CATCH:
        ;
        break;
      default:
        jj_la1[97] = jj_gen;
        break label_15;
      }
      jj_consume_token(CATCH);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      default:
        jj_la1[98] = jj_gen;
        _errorChar('(');
      }
      catchParam = FormalParameter();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RPAREN:
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[99] = jj_gen;
        _errorChar(')');
      }
      tempCatchBlock = Block();
      catchList.add(new CatchBlock(_loc(first), catchParam, tempCatchBlock));
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINALLY:
      jj_consume_token(FINALLY);
      finallyBlock = Block();
      break;
    default:
      jj_la1[100] = jj_gen;
      ;
    }
    CatchBlock[] catches = catchList.toArray(new CatchBlock[0]);
    if (finallyBlock == null) {
      {if (true) return new NormalTryCatchStatement(_loc(first), tryBlock, catches);}
    }
    else {
      {if (true) return new TryCatchFinallyStatement(_loc(first), tryBlock, catches, finallyBlock);}
    }
    throw new Error("Missing return statement in function");
  }

// A statement expression is an expression followed by a semicolon.
  final public StatementExpressionList StatementExpressionList() throws ParseException {
  LinkedList<Expression> expressions = new LinkedList<Expression>();
  Expression exp;
  Token first = getToken(1);
    /** The semicolon terminates each statement expression in a ForInit */
      exp = Expression(",);");
    expressions.addLast(exp);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[101] = jj_gen;
        break label_16;
      }
      jj_consume_token(COMMA);
      exp = Expression(",);");
     expressions.addLast(exp);
    }
     {if (true) return new StatementExpressionList(_loc(first),
                                        expressions.toArray(new Expression[0]));}
    throw new Error("Missing return statement in function");
  }

  final public void PrecedingUnaryOpLookahead() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
      jj_consume_token(INCR);
      break;
    case DECR:
      jj_consume_token(DECR);
      break;
    case TILDE:
      jj_consume_token(TILDE);
      break;
    case BANG:
      jj_consume_token(BANG);
      break;
    case PLUS:
      jj_consume_token(PLUS);
      break;
    case MINUS:
      jj_consume_token(MINUS);
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Expression Expression(String terminator) throws ParseException {
  LinkedList<ExpressionPiece> exprPieceList = new LinkedList<ExpressionPiece>();
  ExpressionPiece exprPiece;
  Expression expr;
  Token nextToken;
  Token first = getToken(1);
    try {
      if (jj_2_30(2)) {
        exprPiece = NonOtherExpression(terminator);
      } else if (jj_2_31(2147483647)) {
        exprPiece = CastExpression(terminator);
      } else if (jj_2_32(2147483647)) {
        exprPiece = DotClass();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FALSE:
        case NULL:
        case SUPER:
        case THIS:
        case TRUE:
        case DECIMAL_LITERAL:
        case HEX_LITERAL:
        case OCTAL_LITERAL:
        case LONG_DECIMAL_LITERAL:
        case LONG_HEX_LITERAL:
        case LONG_OCTAL_LITERAL:
        case DOUBLE_FLOATING_POINT_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACKET:
        case ASSIGN:
        case GT:
        case LT:
        case BANG:
        case TILDE:
        case EQ:
        case LE:
        case GE:
        case NE:
        case SC_OR:
        case SC_AND:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case BIT_AND:
        case BIT_OR:
        case XOR:
        case REM:
        case LSHIFT:
        case RSSHIFT1:
        case RUSHIFT1:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:
          exprPiece = OtherExpression(terminator);
          break;
        default:
          jj_la1[103] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
           exprPieceList.addLast(exprPiece);
      label_17:
      while (true) {
        if (jj_2_33(2)) {
          ;
        } else {
          break label_17;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
          if (jj_2_34(2)) {
            exprPiece = NonOtherExpression(terminator);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              exprPiece = Word();
              break;
            case THIS:
              exprPiece = ThisLiteral();
              break;
            default:
              jj_la1[104] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
                exprPieceList.addLast(exprPiece);
          break;
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INSTANCEOF:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case DECIMAL_LITERAL:
        case HEX_LITERAL:
        case OCTAL_LITERAL:
        case LONG_DECIMAL_LITERAL:
        case LONG_HEX_LITERAL:
        case LONG_OCTAL_LITERAL:
        case DOUBLE_FLOATING_POINT_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACKET:
        case ASSIGN:
        case GT:
        case LT:
        case BANG:
        case TILDE:
        case HOOK:
        case EQ:
        case LE:
        case GE:
        case NE:
        case SC_OR:
        case SC_AND:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case BIT_AND:
        case BIT_OR:
        case XOR:
        case REM:
        case LSHIFT:
        case RSSHIFT1:
        case RUSHIFT1:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:
          if (jj_2_39(2147483647)) {
            if (jj_2_35(2)) {
              exprPiece = NonOtherExpression(terminator);
            } else if (jj_2_36(2147483647)) {
              exprPiece = CastExpression(terminator);
            } else if (jj_2_37(2147483647)) {
              exprPiece = DotClass();
            } else if (jj_2_38(2147483647)) {
              exprPiece = OtherExpression(terminator);
            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
        ExpressionPiece ep = exprPieceList.getLast();
        // If the thing we just read in is not an operator or bracketed(array access), then the previous token must have been an operator.
        //System.out.println("previous = " + ep + " current = " + exprPiece);
        if (!(exprPiece instanceof OtherExpression && (((OtherExpression)exprPiece).getExprPiece() instanceof Operator
                                                         || ((OtherExpression)exprPiece).getExprPiece() instanceof Bracketed))) {
          if (ep instanceof OtherExpression) {
            if (!(((OtherExpression)ep).getExprPiece() instanceof Operator)) {
              //            System.out.println(exprPieceList.getLast() + " " + exprPieceList.getLast().getClass());
              _throwParseException("There must be a keyword or operator before this expression.");
            }
          }
          else {
            _throwParseException("There must be a keyword or operator before this expression.");
          }
        }
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INSTANCEOF:
              //       LOOKAHEAD(<INSTANCEOF>)
                       exprPiece = InstanceOfExpression(terminator);
              break;
            case HOOK:
              //         | LOOKAHEAD(<HOOK>)
                         exprPiece = ConditionalExpression(terminator);
              break;
            default:
              jj_la1[105] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
           exprPieceList.addLast(exprPiece);
          break;
        default:
          jj_la1[106] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          nextToken = getToken(1);
          if (terminator.indexOf(nextToken.image) != -1) {
            {if (true) return new Expression(_loc(first), exprPieceList.toArray(new ExpressionPiece[0]));}
//            return new OtherExpression(_loc(first), (JExpression[])expressions.toArray(new JExpression[0]));
          }
      }
      {if (true) return new Expression(_loc(first), exprPieceList.toArray(new ExpressionPiece[0]));}
    } catch (ParseException pe) {
    if (terminator.indexOf(first.image) != -1) {
      _throwParseException("Missing an expression here");
    }
    StringBuffer message = new StringBuffer();
    for (int i = 0; i < terminator.length(); i++) {
      if (i > 0) {
        if (i == (terminator.length() - 1)) {
          message.append(" or ");
        }
        else {
          message.append(", ");
        }
      }
      message.append(terminator.charAt(i));
    }
    _throwParseException(pe, "This is an invalid expression: " + message.toString() + " expected");
    }
    throw new Error("Missing return statement in function");
  }

/** A NonOtherExpression is an expression that 
 * needs to be parsed to handle possible generic type parameters (so
 * we can match angle brackets)
 * @param terminator A String containing characters that mark the end
 * of this expression.
 */
  final public ExpressionPiece NonOtherExpression(String terminator) throws ParseException {
  ExpressionPiece exprPiece;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      exprPiece = MethodInvocationExpression();
      break;
    case NEW:
      exprPiece = AllocationExpression();
      break;
    default:
      jj_la1[107] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return exprPiece;}
    throw new Error("Missing return statement in function");
  }

//Expression PrimaryPrefix(String terminator) :
//{
//  Expression exp;
//  Word w;
//  Token first = getToken(1);
//}
//{
//  try {
//    ( 
////     LOOKAHEAD(CompoundWord() Arguments())
////       ret = MethodInvocationExpression(ret, terminator)
////       | LOOKAHEAD([ CompoundWord() <DOT> ] <NEW>)
//       exp = AllocationExpression(NO_ALLOCATION_QUALIFIER)
//       | LOOKAHEAD(<LPAREN> Type())
//       exp = CastExpression(terminator)
////       | <LPAREN> Expression(terminator) <RPAREN>
//       | exp = Parenthesized()
//       | <THIS> { exp = new ThisLiteral(_loc(first)); }
//       | <SUPER> <DOT> w = Word()
//       { exp = new SuperMemberAccess(_loc(first), w); }
//     | LOOKAHEAD(DotClass())
//       exp = DotClass()
//       | //LOOKAHEAD(Word() <DOT>)
//     exp = Word()
//       )
//     { return exp; }
//  }
//  catch (ParseException pe) {
//    _throwParseException(pe, "This cannot appear at the start of an expression!");
//  }
//}
//
//Expression PrimarySuffix(Expression prefix, String terminator) :
//{
//  Expression temp;
//  Word word;
//  Expression[] arguments;
//}
//{
//  try {
//    (
//     LOOKAHEAD(2)
//     <DOT> <THIS> { return new DotThis(_loc(prefix), prefix); }
//     |
//     LOOKAHEAD(2)
//       // weird qualified allocation expression!
//       // prefix is the qualifier
//       <DOT> temp = AllocationExpression(prefix)
//       { return temp; }
//     |
//     <LBRACKET> temp = Expression("]") <RBRACKET>
//     { return new ArrayAccess(_loc(prefix), prefix, temp); }
//     |
//     <DOT> word = Word()
//     { return new MemberAccess(_loc(prefix), prefix, word); }
//     |
//     arguments = Arguments()
//       { return new MethodInvocationExpression(_loc(prefix), prefix, arguments); }
//     )
//  }
//  catch (ParseException pe) {
//    _throwParseException(pe, "This cannot appear in the suffix of the expression!");
//  }
//      | 
//      LOOKAHEAD(CompoundWord() Arguments())
//        ret = MethodInvocationExpression(ret, terminator)
//        | LOOKAHEAD([ CompoundWord() <DOT> ] <NEW>)
//        ret = AllocationExpression(ret)
//        | FieldAccess()
//        )
//       |
//     ret = ArrayAccessExpression(ret)
//       )
//      { return ret; }
//}
  final public ConditionalExpression ConditionalExpression(String terminator) throws ParseException {
  Expression conseq;
  Expression alt;
  Token first = getToken(1);
    try {
      jj_consume_token(HOOK);
      conseq = Expression(":");
      jj_consume_token(COLON);
      alt = Expression(terminator);
      {if (true) return new ConditionalExpression(_loc(first), conseq, alt);}
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a condtional expression!");
    }
    throw new Error("Missing return statement in function");
  }

/** Differentiates between array allocations and anonymous inner class definitions
 * @param qualifier the CompoundWord before the new. (e.g. a.new Foo())
 */
  final public AllocationExpression AllocationExpression() throws ParseException {
  PrimitiveType tempPrimitive;
  ReferenceType tempReference;
  AllocationExpression temp;
  BracedBody body = null;
  Expression[] arguments;
  Token first = getToken(1);
    try {
      if (jj_2_41(2)) {
        jj_consume_token(NEW);
        tempPrimitive = PrimitiveType();
        temp = ArrayAllocationExpression(tempPrimitive);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
          jj_consume_token(NEW);
          tempReference = ClassOrInterfaceType();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            temp = ArrayAllocationExpression(tempReference);
            break;
          case LPAREN:
            arguments = Arguments();
            if (jj_2_40(2147483647)) {
              jj_consume_token(LBRACE);
              body = BracedBody();
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case RBRACE:
                jj_consume_token(RBRACE);
                break;
              default:
                jj_la1[108] = jj_gen;
                _errorChar('}');
              }
            } else {
              ;
            }
    if (body == null) {
      temp = new InstanceAllocationExpression(_loc(first),
                                              tempReference,
                                              arguments);
    }
    else {
      temp = new AnonymousInnerClassExpression(_loc(first),
                                               tempReference,
                                               arguments,
                                               body);
    }
            break;
          default:
            jj_la1[109] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[110] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    {if (true) return temp;}
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in an allocation expression!");
    }
    throw new Error("Missing return statement in function");
  }

// an array allocation either has at least one dimension expression
// or it has an initializer. can't have both.
  final public ArrayAllocationExpression ArrayAllocationExpression(Type elementType) throws ParseException {
  LinkedList<Expression> dimensions = new LinkedList<Expression>();
  ArrayType arrayType = null;
  Expression exp;
  ArrayInitializer initializer;
  Token first = getToken(1);
    if (jj_2_45(2)) {
      label_18:
      while (true) {
        jj_consume_token(LBRACKET);
        exp = Expression("]");
        jj_consume_token(RBRACKET);
          if (arrayType == null) {
            arrayType = new ArrayType(_loc(elementType), elementType.getName() + "[]", elementType);
          }
          else {
            arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
          }

          dimensions.add(exp);
        if (jj_2_42(2)) {
          ;
        } else {
          break label_18;
        }
      }
      label_19:
      while (true) {
        if (jj_2_43(2)) {
          ;
        } else {
          break label_19;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
          arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
      }
        {if (true) return new DimensionalArrayAllocationExpression(_loc(first),
                                                        arrayType,
                                                        dimensions.toArray(new Expression[0]));}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        label_20:
        while (true) {
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
          if (arrayType == null) {
            arrayType = new ArrayType(_loc(elementType), elementType.getName() + "[]", elementType);
          }
          else {
            arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
          }
          if (jj_2_44(2)) {
            ;
          } else {
            break label_20;
          }
        }
        initializer = ArrayInitializer();
    {if (true) return new InitializedArrayAllocationExpression(_loc(first),
                                                    arrayType,
                                                    initializer);}
        break;
      default:
        jj_la1[111] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Recognizes: Type (identifier [, initializer ] )+.
 */
  final public LinkedList<VariableDeclarator> VariableDeclaratorList() throws ParseException {
  LinkedList<VariableDeclarator> list = new LinkedList<VariableDeclarator>();

  Type originalType;
  VariableDeclarator current;
    try {
      originalType = Type();
      current = VariableDeclarator(originalType);
      list.add(current);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[112] = jj_gen;
          break label_21;
        }
        jj_consume_token(COMMA);
        current = VariableDeclarator(originalType);
      list.add(current);
      }
      {if (true) return list;}
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a variable declarator!");
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Recognizes an identifier with any number of possible brackets.
 * Figures out the real type by dealing with the fact
 * that [] can be either after type or after identifier!
 * Very strange syntax indeed.
 * TODO: Make sure FormalParameter (or anything else that can't have
 * initialized variable declarators to check for this).
 *
 * @param givenType The type that was recognized before this identifier
 * @return The pair of type and identifier. The type encompasses
 *         all levels of array []s needed (from both after the type and
 *         after the identifier).
 */
  final public VariableDeclarator VariableDeclarator(Type givenType) throws ParseException {
//  VariableDeclarator decl = new VariableDeclarator();
  Type type = givenType;
  Word identifier;
  VariableInitializerI initializer = null;
    identifier = Word();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        jj_la1[113] = jj_gen;
        break label_22;
      }
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
      type = new ArrayType(_loc(identifier), type.getName() + "[]", type);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      initializer = VariableInitializer();
      break;
    default:
      jj_la1[114] = jj_gen;
      ;
    }
    if (initializer == null) {
      {if (true) return new UninitializedVariableDeclarator(_loc(identifier),
                                                 type,
                                                 identifier);}
    }
    else {
      {if (true) return new InitializedVariableDeclarator(_loc(identifier),
                                               type,
                                               identifier,
                                               initializer);}
    }
    throw new Error("Missing return statement in function");
  }

  final public VariableInitializerI VariableInitializer() throws ParseException {
  VariableInitializerI init;
    try {
      if (jj_2_46(2147483647)) {
        init = ArrayInitializer();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case DECIMAL_LITERAL:
        case HEX_LITERAL:
        case OCTAL_LITERAL:
        case LONG_DECIMAL_LITERAL:
        case LONG_HEX_LITERAL:
        case LONG_OCTAL_LITERAL:
        case DOUBLE_FLOATING_POINT_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACKET:
        case ASSIGN:
        case GT:
        case LT:
        case BANG:
        case TILDE:
        case EQ:
        case LE:
        case GE:
        case NE:
        case SC_OR:
        case SC_AND:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case BIT_AND:
        case BIT_OR:
        case XOR:
        case REM:
        case LSHIFT:
        case RSSHIFT1:
        case RUSHIFT1:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:
          init = Expression(",};");
          break;
        default:
          jj_la1[115] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      {if (true) return init;}
    } catch (ParseException pe) {
    _throwParseException(pe, "This is an illegal variable initializer!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayInitializer ArrayInitializer() throws ParseException {
  LinkedList<VariableInitializerI> items = new LinkedList<VariableInitializerI>();
  VariableInitializerI varInit;
  Token first = getToken(1);
    try {
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case LBRACKET:
      case ASSIGN:
      case GT:
      case LT:
      case BANG:
      case TILDE:
      case EQ:
      case LE:
      case GE:
      case NE:
      case SC_OR:
      case SC_AND:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case BIT_AND:
      case BIT_OR:
      case XOR:
      case REM:
      case LSHIFT:
      case RSSHIFT1:
      case RUSHIFT1:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case LSHIFTASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:
        varInit = VariableInitializer();
                                         items.add(varInit);
        label_23:
        while (true) {
          if (jj_2_47(2)) {
            ;
          } else {
            break label_23;
          }
          jj_consume_token(COMMA);
          varInit = VariableInitializer();
                                          items.add(varInit);
        }
        break;
      default:
        jj_la1[116] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[117] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RBRACE:
        jj_consume_token(RBRACE);
        break;
      default:
        jj_la1[118] = jj_gen;
        _errorChar('}');
      }
         {if (true) return new ArrayInitializer(_loc(first),
                                     items.toArray(new VariableInitializerI[0]));}
    } catch (ParseException pe) {
    _throwParseException(pe, "This is an illegal array initializer!");
    }
    throw new Error("Missing return statement in function");
  }

  final public Expression[] Arguments() throws ParseException {
  Expression[] args = new Expression[0];
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:
    case DOUBLE_FLOATING_POINT_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACKET:
    case ASSIGN:
    case GT:
    case LT:
    case BANG:
    case TILDE:
    case EQ:
    case LE:
    case GE:
    case NE:
    case SC_OR:
    case SC_AND:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
    case STAR:
    case SLASH:
    case BIT_AND:
    case BIT_OR:
    case XOR:
    case REM:
    case LSHIFT:
    case RSSHIFT1:
    case RUSHIFT1:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:
      args = ArgumentList();
      break;
    default:
      jj_la1[119] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
    {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

  final public Expression[] ArgumentList() throws ParseException {
  LinkedList<Expression> list = new LinkedList<Expression>();
  Expression temp;
    try {
      temp = Expression(",)");
                              list.add(temp);
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[120] = jj_gen;
          break label_24;
        }
        jj_consume_token(COMMA);
        temp = Expression(",)");
                              list.add(temp);
      }
      {if (true) return list.toArray(new Expression[0]);}
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in an argument list!");
    }
    throw new Error("Missing return statement in function");
  }

  final public MethodInvocationExpression MethodInvocationExpression() throws ParseException {
  Word left;
  Expression[] arguments;
  Token first = getToken(1);
    try {
      left = Word();
      arguments = Arguments();
      {if (true) return new MethodInvocationExpression(_loc(first),
                                            left,
                                            arguments);}
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a method invocation expression!");
    }
    throw new Error("Missing return statement in function");
  }

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.  We need this check to disambiguate from an expression like (x) + 3.
  final public void CastLookahead() throws ParseException {
    if (jj_2_48(2)) {
      jj_consume_token(LPAREN);
      PrimitiveType();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          jj_la1[121] = jj_gen;
          break label_25;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
      }
      jj_consume_token(RPAREN);
    } else if (jj_2_49(2147483647)) {
      jj_consume_token(LPAREN);
      CompoundWord();
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        CompoundWord();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          jj_consume_token(TILDE);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case THIS:
          jj_consume_token(THIS);
          break;
        case SUPER:
          jj_consume_token(SUPER);
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        case FALSE:
        case NULL:
        case TRUE:
        case DECIMAL_LITERAL:
        case HEX_LITERAL:
        case OCTAL_LITERAL:
        case LONG_DECIMAL_LITERAL:
        case LONG_HEX_LITERAL:
        case LONG_OCTAL_LITERAL:
        case DOUBLE_FLOATING_POINT_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
          Literal();
          break;
        default:
          jj_la1[122] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[123] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public CastExpression CastExpression(String terminator) throws ParseException {
  Expression value;
  Type type;
  Token first = getToken(1);
    jj_consume_token(LPAREN);
    type = Type();
    jj_consume_token(RPAREN);
    value = Expression(terminator);
    {if (true) return new CastExpression(_loc(first), type, value);}
    throw new Error("Missing return statement in function");
  }

  final public InstanceOfExpression InstanceOfExpression(String terminator) throws ParseException {
  Type type;
  Token first = getToken(1);
    try {
      jj_consume_token(INSTANCEOF);
      type = Type();
      {if (true) return new InstanceOfExpression(_loc(first), type);}
    } catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in an instanceof expression!");
    }
    throw new Error("Missing return statement in function");
  }

  final public void DotClassLookahead() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      jj_consume_token(VOID);
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        PrimitiveType();
        break;
      case IDENTIFIER:
        if (jj_2_50(2)) {
          ClassOrInterfaceType();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            TypeVariable();
            break;
          default:
            jj_la1[124] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[125] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          jj_la1[126] = jj_gen;
          break label_26;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
      }
      break;
    default:
      jj_la1[127] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(DOT);
    jj_consume_token(CLASS);
  }

  final public DotClass DotClass() throws ParseException {
  ReturnTypeI type;
  Token first = getToken(1);
    type = ReturnType();
    jj_consume_token(DOT);
    jj_consume_token(CLASS);
    {if (true) return new DotClass(_loc(first), type);}
    throw new Error("Missing return statement in function");
  }

  final public OtherExpression OtherExpression(String terminator) throws ParseException {
  Token nextToken;
  ExpressionPiece expr;
  Token first = getToken(1);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        // Perhaps we should make each of these implement OtherExpressionI?
        //      LOOKAHEAD(NonOtherExpression(terminator))
        //        expr = NonOtherExpression(terminator) |
        //      expr = Braced() |
              expr = Bracketed();
        break;
      case LPAREN:
        // for array allocation
              expr = Parenthesized();
        break;
      case ASSIGN:
      case GT:
      case LT:
      case BANG:
      case TILDE:
      case EQ:
      case LE:
      case GE:
      case NE:
      case SC_OR:
      case SC_AND:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case BIT_AND:
      case BIT_OR:
      case XOR:
      case REM:
      case LSHIFT:
      case RSSHIFT1:
      case RUSHIFT1:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case LSHIFTASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:
        // for arithmetic or grouping of expressions
              expr = Operator();
        break;
      case FALSE:
      case NULL:
      case TRUE:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
        expr = Literal();
        break;
      case THIS:
        expr = ThisLiteral();
        break;
      case SUPER:
        expr = SuperLiteral();
        break;
      case IDENTIFIER:
        //      LOOKAHEAD(Word() <DOT>)
        //      expr = CompoundWord() |
              expr = Word();
        break;
      default:
        jj_la1[128] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      {if (true) return new OtherExpression(_loc(first), expr);}
    } catch (ParseException pe) {
    _throwParseException(pe, "This is an illegal expression!");
    }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  final private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  final private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  final private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  final private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  final private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  final private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  final private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  final private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  final private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  final private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  final private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  final private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  final private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  final private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  final private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  final private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  final private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_3R_97()) return true;
    }
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_274()) return true;
    }
    return false;
  }

  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_59()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_217()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_218()) return true;
    }
    return false;
  }

  final private boolean jj_3_46() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) return true;
    }
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_34()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(SUPER)) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_3R_34()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) jj_scanpos = xsp;
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_35()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    }
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_35()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_3R_88()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_145()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_146()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(THIS)) return true;
    if (jj_3R_35()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) return true;
    }
    return false;
  }

  final private boolean jj_3R_229() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_227() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_243() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_228() {
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_90()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_91()) return true;
    }
    return false;
  }

  final private boolean jj_3R_226() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_242()) return true;
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_3R_32()) return true;
    if (jj_3R_128()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_243()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_223()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_227()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_229()) return true;
    }
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_170()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3_28() {
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(PACKAGE)) return true;
    return false;
  }

  final private boolean jj_3_44() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(IMPORT)) return true;
    return false;
  }

  final private boolean jj_3R_221() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_198() {
    if (jj_3R_216()) return true;
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_3R_215()) return true;
    return false;
  }

  final private boolean jj_3R_202() {
    Token xsp;
    if (jj_3_44()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_44()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_196() {
    if (jj_3R_214()) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  final private boolean jj_3R_195() {
    if (jj_3R_213()) return true;
    return false;
  }

  final private boolean jj_3_43() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_95() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) jj_scanpos = xsp;
    if (jj_3R_32()) return true;
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_194() {
    if (jj_3R_212()) return true;
    return false;
  }

  final private boolean jj_3R_241() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_193() {
    if (jj_3R_211()) return true;
    return false;
  }

  final private boolean jj_3R_192() {
    if (jj_3R_210()) return true;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_3R_209()) return true;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_3R_208()) return true;
    return false;
  }

  final private boolean jj_3R_239() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_3R_207()) return true;
    return false;
  }

  final private boolean jj_3R_188() {
    if (jj_3R_206()) return true;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_244() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_3R_205()) return true;
    return false;
  }

  final private boolean jj_3_42() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_3R_204()) return true;
    return false;
  }

  final private boolean jj_3R_240() {
    if (jj_3R_95()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_244()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_223() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_239()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_240()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_241()) return true;
    }
    return false;
  }

  final private boolean jj_3_45() {
    Token xsp;
    if (jj_3_42()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_42()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_43()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_172() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_45()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    }
    return false;
  }

  final private boolean jj_3R_170() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_40() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_90()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_221()) return true;
    }
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_3R_35()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_3R_172()) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) return true;
    }
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_3R_88()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_89()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_37()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) return true;
    }
    return false;
  }

  final private boolean jj_3_41() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_36()) return true;
    if (jj_3R_172()) return true;
    return false;
  }

  final private boolean jj_3R_245() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_105() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    }
    return false;
  }

  final private boolean jj_3R_242() {
    if (jj_3R_37()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_245()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_134() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_3R_27()) return true;
    if (jj_3R_184()) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_134()) return true;
    }
    return false;
  }

  final private boolean jj_3R_225() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_242()) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_222() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_133() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_224() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    }
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_3R_27()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_183()) jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    if (jj_3R_88()) return true;
    if (jj_3R_223()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_224()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_225()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_27()) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_31()) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_105()) return true;
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_scan_token(RUSHIFT1)) return true;
    if (jj_scan_token(RUSHIFT2)) return true;
    if (jj_scan_token(RUSHIFT3)) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_147() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) return true;
    }
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_scan_token(RSSHIFT1)) return true;
    if (jj_scan_token(RSSHIFT2)) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_3R_170()) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) return true;
    }
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_3R_169()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_222()) return true;
    }
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_3R_168()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_3R_167()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_3R_166()) return true;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_3R_147()) return true;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_3R_165()) return true;
    return false;
  }

  final private boolean jj_3R_142() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_3R_116()) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_3R_115()) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_3R_142()) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_123()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_119() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_3R_135()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_38() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3_37() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3_36() {
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_35()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_3R_101()) return true;
    return false;
  }

  final private boolean jj_3_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_3R_100()) return true;
    return false;
  }

  final private boolean jj_3_35() {
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_3R_27()) return true;
    if (jj_3R_182()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_238() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_237() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_3R_111()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_34() {
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_279() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_236() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_242()) return true;
    return false;
  }

  final private boolean jj_3R_235() {
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3_32() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_scan_token(INTERFACE)) return true;
    if (jj_3R_88()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_235()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_236()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_237()) return true;
    }
    if (jj_3R_90()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_238()) return true;
    }
    return false;
  }

  final private boolean jj_3_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) return true;
    }
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_31() {
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_3R_101()) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_3R_100()) return true;
    return false;
  }

  final private boolean jj_3_30() {
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(SUPER)) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_33()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  final private boolean jj_3R_285() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  final private boolean jj_3R_284() {
    if (jj_3R_34()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_285()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_150() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) return true;
    }
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  final private boolean jj_3R_278() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_270() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_271() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_273() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_3R_27()) return true;
    if (jj_3R_181()) return true;
    return false;
  }

  final private boolean jj_3R_269() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_234() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_272() {
    if (jj_scan_token(CATCH)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_278()) return true;
    }
    if (jj_3R_95()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_279()) return true;
    }
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_233() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(DOUBLE_FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_215() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_54()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_272()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_273()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_149() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) return true;
    }
    return false;
  }

  final private boolean jj_3R_232() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_242()) return true;
    return false;
  }

  final private boolean jj_3R_231() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_267() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_230() {
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_scan_token(CLASS)) return true;
    if (jj_3R_88()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_231()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_232()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_233()) return true;
    }
    if (jj_3R_90()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_234()) return true;
    }
    return false;
  }

  final private boolean jj_3R_214() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_271()) return true;
    }
    if (jj_3R_34()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_scan_token(LONG_HEX_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_213() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_270()) return true;
    }
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(LONG_OCTAL_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_266() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_268() {
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_scan_token(LONG_DECIMAL_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_261() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_268()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_269()) return true;
    }
    return false;
  }

  final private boolean jj_3R_256() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_scan_token(HEX_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_scan_token(OCTAL_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(77)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_267()) return true;
    }
    return false;
  }

  final private boolean jj_3R_254() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_175() {
    if (jj_scan_token(DECIMAL_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_263() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_148() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) return true;
    }
    return false;
  }

  final private boolean jj_3R_159() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_265() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_260() {
    if (jj_3R_276()) return true;
    return false;
  }

  final private boolean jj_3R_210() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(77)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_266()) return true;
    }
    return false;
  }

  final private boolean jj_3R_258() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_277() {
    if (jj_3R_284()) return true;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(29)) jj_scanpos = xsp;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_3R_143()) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_52()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_3R_96()) return true;
    return false;
  }

  final private boolean jj_3R_255() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_3R_143()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_283() {
    if (jj_3R_284()) return true;
    return false;
  }

  final private boolean jj_3R_259() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_282() {
    if (jj_3R_169()) return true;
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_3R_96()) return true;
    return false;
  }

  final private boolean jj_3R_276() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3R_283()) return true;
    }
    return false;
  }

  final private boolean jj_3R_126() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_3R_121()) return true;
    return false;
  }

  final private boolean jj_3R_264() {
    if (jj_3R_277()) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_3R_111()) return true;
    return false;
  }

  final private boolean jj_3R_262() {
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_3R_119()) return true;
    return false;
  }

  final private boolean jj_3R_257() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_209() {
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_259()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_260()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_261()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_262()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_263()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_264()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_265()) return true;
    }
    if (jj_3R_170()) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    return false;
  }

  final private boolean jj_3R_253() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_124()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_125()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_126()) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3_50() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_50()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) return true;
    }
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_170()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_3R_255()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_256()) return true;
    }
    if (jj_3R_34()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_257()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_258()) return true;
    }
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_3R_56()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_201() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) return true;
    }
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_scan_token(WHILE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_253()) return true;
    }
    if (jj_3R_34()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_254()) return true;
    }
    if (jj_3R_170()) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_3R_150()) return true;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_110()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_251() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_3R_149()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    }
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(LT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_201()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_126()) return true;
    return false;
  }

  final private boolean jj_3R_250() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_3R_148()) return true;
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3R_120() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_252() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_170()) return true;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_3R_103()) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_scan_token(IF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_250()) return true;
    }
    if (jj_3R_34()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_251()) return true;
    }
    if (jj_3R_170()) return true;
    xsp = jj_scanpos;
    if (jj_3R_252()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_171()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_3R_96()) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_3R_103()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_281() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  final private boolean jj_3R_247() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) return true;
    }
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_3R_143()) return true;
    return false;
  }

  final private boolean jj_3R_246() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3_49() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_51()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_280() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  final private boolean jj_3R_275() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_280()) {
    jj_scanpos = xsp;
    if (jj_3R_281()) return true;
    }
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_66()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_21()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_249() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_51()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_107()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_27()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_51()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3_48() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_36()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_106()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_48()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_248() {
    if (jj_3R_275()) return true;
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_scan_token(SWITCH)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_246()) return true;
    }
    if (jj_3R_34()) return true;
    if (jj_scan_token(RPAREN)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_247()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_248()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    }
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) return true;
    }
    if (jj_3R_68()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_68()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_3R_88()) return true;
    if (jj_3R_35()) return true;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) return true;
    }
    return false;
  }

  final private boolean jj_3R_274() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_3R_96()) return true;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_218() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_3R_34()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_130()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_97() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3_47() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_3R_50()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_47()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  public ACParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[129];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xffffe000,0xffffe000,0x0,0xa2094000,0x20002000,0x20002000,0x0,0x10000000,0x0,0x20002000,0x20002000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0xb359e000,0x0,0x9349c000,0x0,0x0,0x0,0x0,0x0,0x0,0x82094000,0x0,0x0,0xa2094000,0x0,0x20000000,0x0,0x0,0x0,0x0,0x92094000,0x0,0x0,0x0,0x82094000,0x0,0x0,0x0,0x0,0x82094000,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x1408000,0x0,0x0,0x0,0x0,0x820000,0x0,0x820000,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb2096000,0x0,0x92094000,0x0,0x92094000,0x0,0x92094000,0x0,0x0,0x0,0x0,0x92094000,0x0,0x0,0x0,0x40000,0x0,0x0,0x40000000,0x0,0x0,0x10000000,0x0,0x0,0x92094000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x92094000,0x92094000,0x0,0x0,0x92094000,0x0,0x0,0x10000000,0x0,0x0,0x82094000,0x0,0x82094000,0x10000000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0xffffffff,0xffffffff,0x0,0x20140,0x4408e000,0x4408e000,0x0,0x8000800,0x0,0x444ce200,0x444ce200,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0xfdffefc5,0x0,0xb9f30d45,0x0,0x2000000,0x0,0x0,0x0,0x0,0x20020140,0x0,0x0,0x20140,0x0,0x0,0x2000000,0x0,0x0,0x0,0x28920d40,0x80000,0x0,0x0,0x20140,0x0,0x0,0x0,0x0,0x20140,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x91610005,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x6cdeef40,0x0,0x28920d40,0x0,0x28920d40,0x0,0x28920d40,0x0,0x0,0x0,0x0,0x28920d40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8900800,0x800000,0x20,0x28920d60,0x400,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x28920d40,0x28920d40,0x0,0x0,0x28920d40,0x0,0x0,0x8900c00,0x0,0x0,0x20140,0x0,0x20020140,0x8900800,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0xffffe6ff,0xffffe6ff,0x2000000,0xa000,0x0,0x0,0xb40000,0x6ff,0x400000,0x0,0x0,0x2000000,0x0,0x0,0x10000,0x20000,0x2000000,0x0,0x10000,0x20000,0xcf9566ff,0x100000,0xcf9566ff,0x2000000,0x0,0x10000,0x20000,0x100000,0x200000,0x2000,0x4000,0x200000,0x2000,0x8000,0x0,0x0,0x10000,0x20000,0x100000,0xcf8466ff,0x0,0x2000,0x80000,0x0,0x2000,0x2000,0x40000,0x2000,0x202000,0x200000,0x2000,0x202000,0x200000,0x1000000,0x0,0x7,0x38,0x3f,0xc0,0x0,0xcf800000,0x0,0x80000,0x8000,0x100000,0x20000,0x100000,0x4000,0x10000,0x0,0x20000,0x0,0x4000,0x8000,0x0,0x4000,0x8000,0x0,0x4000,0x8000,0x100000,0x4000,0xcf8466ff,0x100000,0xcf8466ff,0x100000,0xcf8466ff,0x8000,0xcf8466ff,0x2000,0x100000,0x2000,0x100000,0xcf8466ff,0x100000,0x100000,0x4000,0x0,0x4000,0x8000,0x0,0x200000,0xc000000,0xcf8466ff,0x2000,0x10000000,0xdfc466ff,0x2000,0x20000,0x44000,0x0,0x40000,0x200000,0x40000,0x800000,0xcf8466ff,0xcf8566ff,0x200000,0x20000,0xcf8466ff,0x200000,0x40000,0xc0066ff,0x4000,0x2000,0x2000,0x40000,0x2000,0xcf8466ff,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0xfffeffff,0xfffeffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffca7fff,0x0,0xffca7fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffca7fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e0000,0x0,0x0,0x0,0x0,0x0,0x0,0xffca7fff,0xa0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffca7fff,0x0,0xffca7fff,0x0,0xffca7fff,0x0,0xffca7fff,0x0,0x0,0x0,0x0,0xffca7fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0xffca7fff,0x0,0x0,0xffca7fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffca7fff,0xffca7fff,0x0,0x0,0xffca7fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffca7fff,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[50];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public ACParser(java.io.InputStream stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ACParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 129; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 129; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ACParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ACParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 129; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 129; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ACParser(ACParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 129; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ACParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 129; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[130];
    for (int i = 0; i < 130; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 129; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 130; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 50; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

//class VariableDeclarator {
//  public Word identifier;
//  public Type type;
//  public VariableInitializerI initializer = ACParser.NO_VARIABLE_INITIALIZER;
//}

class UnmodifiedClassDef {
  public Word name;
  // provide defaults here for things that can be unspecified
  public TypeParameter[] typeParameters = new TypeParameter[0];
  public ReferenceType superclass = ACParser.NO_TYPE;
  public ReferenceType[] interfaces = new ReferenceType[0];
  public BracedBody body;
}

class UnmodifiedInterfaceDef {
  public Word name;
  public TypeParameter[] typeParameters = new TypeParameter[0];
  public ReferenceType[] superinterfaces = new ReferenceType[0];
  public BracedBody body;
//  public AbstractMethodDef[] methods = new AbstractMethodDef[0];
//  public FinalStaticFieldDef[] fields = new FinalStaticFieldDef[0];
//  public StaticInnerDefI[] inners = new StaticInnerDefI[0];
}
