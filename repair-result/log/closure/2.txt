Repair : closure_2
Current failed test : com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces | 2019.09.10 AD at 05:31:39 CDT
Location : com.google.javascript.rhino.jstype.ObjectType.isUnknownType:[575, 576, 574, 580, 568, 569, 570, 572, 573, 583, 578]#1.0
Compute Candidate : 2019.09.10 AD at 05:33:45 CDT - 2019.09.10 AD at 05:54:09 CDT , PNumber : 11416, CandNumber : 245 
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+continue;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:54:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
-return unknown;
+return false;
 }

PATTERN : /home/jiajun/GithubData/2011/V2/2886/pattern-ver1-serial/src.freenet.node.CHKInsertSender.java-shouldTimeout.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:54:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
-ObjectType implicitProto=getImplicitPrototype();
+ ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:54:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import java.util.Collections;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
-return unknown;
+return true;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4457/pattern-ver1-serial/library.src.main.java.com.gh.bmd.jrt.core.DefaultResultChannel.java-isOutputChannelOpen.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:54:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null&&implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V17/3484/pattern-ver1-serial/src.com.massivecraft.creativegates.MainListener.java-stabilizePortalContent.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:54:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+return false;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:54:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+return false;
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:55:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+return false;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:55:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+return false;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:55:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto!=null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/4111/pattern-ver1-serial/tephra-core.src.main.java.co.cask.tephra.snapshot.SnapshotCodecV4.java-encodeInProgress.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:55:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+break;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:55:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+return true;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:55:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+return true;
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:55:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+return true;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:55:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+return true;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:56:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(implicitProto.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/668/pattern-ver1-serial/src.jp.ac.aiit.jointry.controllers.MainController.java-initialize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:56:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
+if(true){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:56:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null!=implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/4891/pattern-ver1-serial/app.src.main.java.edu.temple.androidpermissions.MainActivity.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:56:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
-unknown=false;
+unknown=true;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6486/pattern-ver1-serial/src.noughtsandcrosses.VictoryConditions.java-gameWon.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:56:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
-return unknown;
+return this.unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/1924/pattern-ver1-serial/src.main.java.org.spongepowered.api.util.command.ImmutableCommandMapping.java-getCallable.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:56:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
-return unknown;
+return this.isUnknownType();
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6962/pattern-ver1-serial/CodenameOne.src.com.codename1.ui.Toolbar.java-constructSideNavigationComponent.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:56:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(!interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V12/6908/pattern-ver1-serial/mainModule.src.backend.building.ProductionBuilding.java-canBuild.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:56:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+this.isUnknownType();
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:57:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+this.isUnknownType();
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:57:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+this.isUnknownType();
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:57:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+this.isUnknownType();
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:57:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+this.isUnknownType();
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:57:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+this.isUnknownType();
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:57:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
+if(!unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/5542/pattern-ver1-serial/RedZone.redzone.blocks.Pipe.java-onBlockPlaced.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:57:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(true){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:57:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||!implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/6688/pattern-ver1-serial/src.MineralOre.java-update.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:58:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
+unknown=true;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6486/pattern-ver1-serial/src.noughtsandcrosses.VictoryConditions.java-gameWon.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:58:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+for(ObjectType valueAnimator : getCtorExtendedInterfaces()){
+if(valueAnimator.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/3559/pattern-ver1-serial/library.src.main.java.qiu.niorgai.StatusBarCompatLollipop.java-onAnimationUpdate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:58:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+return false;
 }
 }else {
 unknown=implicitProto.isUnknownType();
+return false;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/4557/pattern-ver1-serial/src.de.rincewind.api.gui.elements.ElementCounter.java-setCount.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:58:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+synchronized(this){
 unknown=true;
+}
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:58:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+synchronized(this){
 unknown=implicitProto.isUnknownType();
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:58:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+for(ObjectType edge : getCtorExtendedInterfaces()){
+if(edge.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1943/pattern-ver1-serial/violet-framework.src.main.java.com.horstmann.violet.product.diagram.abstracts.node.AbstractNode.java-addConnection.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:58:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+for(ObjectType methodOpeningBrace : getCtorExtendedInterfaces()){
+if(methodOpeningBrace.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/3430/pattern-ver1-serial/sevntu-checks.src.main.java.com.github.sevntu.checkstyle.checks.coding.FinalizeImplementationCheck.java-hasTryFinallyBlock.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:58:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
+unknown=false;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2195/pattern-ver1-serial/src.main.java.ian.hu.webapp.session.FileSessionRepository.java-setStorageDirectory.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:59:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+for(ObjectType mpR : getCtorExtendedInterfaces()){
+if(mpR.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/2030/pattern-ver1-serial/app.src.main.java.com.example.andreas.mainview.slashy.SlashyActivity.java-onCompletion.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:59:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
-return unknown;
+return (boolean)(unknown);
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/1621/pattern-ver1-serial/src.lab4.FileService.FileService.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:59:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+return false;
 }
+return false;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/144/pattern-ver1-serial/lettuce.src.main.java.com.lambdaworks.redis.Connections.java-close.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:59:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+for(ObjectType methodAST : getCtorExtendedInterfaces()){
+if(methodAST.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/3430/pattern-ver1-serial/sevntu-checks.src.main.java.com.github.sevntu.checkstyle.checks.coding.CustomDeclarationOrderCheck.java-isMainMethodParameters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 05:59:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
+while(true){
+
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:01:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
+while(true){
+
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:03:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
+while(true){
+
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:03:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+while(true){
+
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:05:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+for(ObjectType managerFactory : getCtorExtendedInterfaces()){
+if(managerFactory.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V17/1774/pattern-ver1-serial/src.main.java.com.spontaneous.server.SpontaneousApplication.java-sessionFactory.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:05:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(unknown){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/7120/pattern-ver1-serial/app.src.main.java.com.codephillip.intmain.fitracer.MainActivity.java-run.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:05:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto!=null&&implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V10/7445/pattern-ver1-serial/bungeecord.src.main.java.com.vexsoftware.votifier.bungee.forwarding.OnlineForwardPluginMessagingForwardingSource.java-forward.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+synchronized(this){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+synchronized(this){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+synchronized(this){
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+for(ObjectType methodOpeningBraceToken : getCtorExtendedInterfaces()){
+if(methodOpeningBraceToken.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/3430/pattern-ver1-serial/sevntu-checks.src.main.java.com.github.sevntu.checkstyle.checks.coding.FinalizeImplementationCheck.java-isMethodEmpty.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+if(implicitProto!=null){
 unknown=implicitProto.isUnknownType();
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/6354/pattern-ver1-serial/src.cager.jexpr.visitor.BoogieVisitor.java-visitPrimaryExpression.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+implicitProto=this;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/4878/pattern-ver1-serial/app.src.main.java.com.trukr.shipper.activity.Notification.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+synchronized(this){
 unknown=true;
 break;
+}
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+if(getCtorExtendedInterfaces()!=null){
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1943/pattern-ver1-serial/app.src.main.java.br.com.battista.myoffers.controller.OfferController.java-saveOfferInDatabase.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:06:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+interfaceType=interfaceType;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:07:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+if(interfaceType!=null){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/4672/pattern-ver1-serial/main.src.main.java.com.example.wduello.collectionmanager.ItemListFragment.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:07:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(interfaceType.isUnknownType()&&unknown){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2749/pattern-ver1-serial/Stuyablo.java-combat.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:07:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
+if(unknown&&unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2749/pattern-ver1-serial/Stuyablo.java-combat.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:07:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||implicitProto.equals("")){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/347/pattern-ver1-serial/app.src.main.java.jog.my.memory.Home.HomeFragment.java-updateProfileName.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:07:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(interfaceType.isUnknownType()==false){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:07:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+int a=0;
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:07:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+int a=0;
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:07:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+int a=0;
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:08:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+int a=0;
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:08:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+int a=0;
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:08:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+int a=0;
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:08:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+unknown=true;
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
+unknown=false;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:08:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+unknown=true;
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
+unknown=false;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:08:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+unknown=true;
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
+unknown=false;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:08:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
 unknown=true;
+if(interfaceType.isUnknownType()){
+unknown=false;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:08:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
+unknown=false;
 break;
 }
 }
 }else {
+unknown=true;
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:09:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
+unknown=false;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:09:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+unknown=false;
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:09:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+unknown=false;
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:09:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+unknown=false;
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:09:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+unknown=false;
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:09:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+String OUTSTRING="";
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:09:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+String OUTSTRING="";
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:09:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+String OUTSTRING="";
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:10:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+String OUTSTRING="";
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:10:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+String OUTSTRING="";
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:10:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+String OUTSTRING="";
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:10:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(unknown&&(interfaceType.isUnknownType())){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:10:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
+if(unknown&&(unknown)){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:10:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+int unknown=5;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/7018/pattern-ver1-serial/app.src.main.java.com.priteshjain.popularmovies.util.EndlessRecyclerOnScrollListener.java-onScrolled.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:10:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+int interfaceType=5;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/7018/pattern-ver1-serial/app.src.main.java.com.priteshjain.popularmovies.util.EndlessRecyclerOnScrollListener.java-onScrolled.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:10:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(interfaceType.isUnknownType()||unknown){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:11:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
+if(unknown||unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:11:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(interfaceType.isUnknownType()==true){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:11:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:11:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:11:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:11:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:11:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+if(equals(interfaceType)){
+return false;
+}
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:11:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if(equals(implicitProto)){
+return false;
+}
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:12:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+int indexSelection=0;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:12:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+int indexSelection=0;
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:12:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+int indexSelection=0;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:12:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+int indexSelection=0;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:12:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+if(interfaceType.equals("sounds")){
+continue;
+}
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:12:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if("Chrome".equals(implicitProto)||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V17/4219/pattern-ver1-serial/src.browsermator.com.STAppController.java-itemStateChanged.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:12:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+int a=1;
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:12:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+int a=1;
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:13:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+int a=1;
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:13:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+int a=1;
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:13:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+int a=1;
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:13:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+int a=1;
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:13:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+boolean unknown=true;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V29/4636/pattern-ver1-serial/core.src.io.github.emergentorganization.cellrpg.input.player.MovementControls.PathDraw.java-process.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:13:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+boolean interfaceType=true;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V29/4636/pattern-ver1-serial/core.src.io.github.emergentorganization.cellrpg.input.player.MovementControls.PathDraw.java-process.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:13:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+boolean b=true;
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:13:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+boolean b=true;
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:14:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+boolean b=true;
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:14:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+boolean b=true;
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:14:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+boolean b=true;
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:14:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+boolean b=true;
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:14:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+if(interfaceType==null){
+continue;
+}
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:14:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
+if(interfaceType==null){
+return false;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:14:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if(implicitProto==null){
+return false;
+}
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:14:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+if(implicitProto==null){
+return false;
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:15:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+unknown=true;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:15:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+unknown=true;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:15:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+unknown=true;
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:15:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
+unknown=true;
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:15:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
+unknown=true;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:15:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+unknown=true;
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:15:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+unknown=true;
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:15:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+unknown=true;
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:16:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+unknown=true;
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:16:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+unknown=true;
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:16:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
 unknown=true;
+if(interfaceType.isUnknownType()){
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:16:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+unknown=true;
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:16:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
 }else {
+unknown=true;
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:16:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+unknown=true;
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:16:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
+unknown=true;
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:16:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+if(!(interfaceType==null)){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5193/pattern-ver1-serial/IJC_UI.src.nl.detoren.ijc.ui.view.Hoofdscherm.java-updateUpdateStandButton.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:17:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+unknown=true;
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/5647/pattern-ver1-serial/src.worms.model.statements.Print.java-executeStatement.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:17:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+unknown=true;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:17:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+unknown=true;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:17:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+unknown=true;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:17:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if(implicitProto.equals("-1")){
+return false;
+}
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:17:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
+if(this.unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
+this.unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7075/pattern-ver1-serial/mind-map.nb-mind-map.src.main.java.com.igormaznitsa.nbmindmap.nb.MMDGraphEditor.java-componentActivated.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:17:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
+if(this.unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
-unknown=false;
+this.unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7075/pattern-ver1-serial/mind-map.nb-mind-map.src.main.java.com.igormaznitsa.nbmindmap.nb.MMDGraphEditor.java-componentActivated.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:17:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
+if(this.unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
+this.unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7075/pattern-ver1-serial/mind-map.nb-mind-map.src.main.java.com.igormaznitsa.nbmindmap.nb.MMDGraphEditor.java-componentActivated.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+unknown=true;
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
+unknown=true;
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+unknown=true;
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
+unknown=true;
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+unknown=true;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
-unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if(unknown){
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+try{
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
+}finally{
+unknown=true;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 1, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+assert (interfaceType!=null);
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:18:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+assert (implicitProto!=null);
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:19:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+assert (implicitProto!=null);
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:19:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+if(interfaceType!=null){
+if(interfaceType.isUnknownType()){
+unknown=true;
+break;
+}
+}
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:19:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+if(implicitProto!=null){
+unknown=implicitProto.isUnknownType();
+}
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:19:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+assert (implicitProto!=getImplicitPrototype());
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:19:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+assert (interfaceType!=null);
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:19:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+assert (implicitProto!=null);
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:19:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if(implicitProto.equals("655")){
+System.out.println();
+}
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3726/pattern-ver1-serial/src.protosocket.client.WriteThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:19:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+unknown=implicitProto.isUnknownType();
 }
 }else {
-unknown=implicitProto.isUnknownType();
+unknown=true;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/835/pattern-ver1-serial/app.src.main.java.ru.android.challenge.telegramchallenge1.handlers.BaseHandler.java-onResult.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 3, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:20:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if((Thread.currentThread().interrupted())){
+return false;
+}
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:20:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
+if((Thread.currentThread().interrupted())){
+return false;
+}
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:20:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+if((Thread.currentThread().interrupted())){
+return false;
+}
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:20:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
+if((Thread.currentThread().interrupted())){
+return false;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:20:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+if((Thread.currentThread().interrupted())){
+return false;
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:20:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
 }
+if((Thread.currentThread().interrupted())){
+return false;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:20:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+boolean unknown=this.unknown;
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/290/pattern-ver1-serial/nars_logic.src.main.java.nars.task.DefaultTask.java-hashCode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:20:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(interfaceType!=null&&interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5865/pattern-ver1-serial/gde-webapp.src.main.java.com.nagarro.gde.validator.UserInternaturValidator.java-validateRequiredData.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:21:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+unknown=implicitProto.isUnknownType();
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:21:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+unknown=implicitProto.isUnknownType();
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:21:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+unknown=implicitProto.isUnknownType();
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:21:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+unknown=implicitProto.isUnknownType();
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:21:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
+unknown=implicitProto.isUnknownType();
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:21:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+unknown=implicitProto.isUnknownType();
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:21:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+unknown=implicitProto.isUnknownType();
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:21:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+unknown=implicitProto.isUnknownType();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:22:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
+unknown=implicitProto.isUnknownType();
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:22:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+unknown=implicitProto.isUnknownType();
 }
 }else {
-unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:22:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+unknown=implicitProto.isUnknownType();
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:22:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+unknown=implicitProto.isUnknownType();
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:22:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+unknown=implicitProto.isUnknownType();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:22:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||implicitProto.equals("manufacturedOn")||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V37/509/pattern-ver1-serial/product-validation-system-war.src.main.java.com.pvs.web.freemarker.processors.ProductTemplateRegistrationProcessor.java-postHTML.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:22:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if((interfaceType!=null)&&(interfaceType.isUnknownType())){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/4845/pattern-ver1-serial/app.src.main.java.hu.bme.aut.szabolcs.szokol.countryinfo.ui.main.MainActivity.java-onBackPressed.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:22:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(!unknown){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V37/918/pattern-ver1-serial/src.com.isrtk.nihtfti.MainService.java-onStartCommand.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 2, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:23:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
-}else {
 unknown=implicitProto.isUnknownType();
+}else {
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/3822/pattern-ver1-serial/app.src.main.java.com.peprally.jeremy.peprally.activities.ProfileActivity.java-SetupNewUserProfile.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:23:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:23:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:23:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:23:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:23:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+unknown=implicitProto.isUnknownType();
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V39/1103/pattern-ver1-serial/Graphs.src.com.jmga.graphs.classes.GView.java-update.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:23:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(interfaceType==null||interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V23/443/pattern-ver1-serial/bundles.opaeum-compilation.org.opaeum.compilation.java.src.org.opaeum.javageneration.bpm.actions.AbstractProtectedNodeBuilder.java-implementCallbackOnComplete.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:23:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||(implicitProto!=null&&implicitProto.isNativeObjectType())){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/2463/pattern-ver1-serial/src.Level.java-collides.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:24:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:24:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:24:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:24:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:24:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+assert (interfaceType!=null):"Appointments day is not allowed to be null!";
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:24:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+assert (implicitProto!=null):"Appointments day is not allowed to be null!";
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:24:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+assert (implicitProto!=null):"Appointments day is not allowed to be null!";
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:24:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+unknown=implicitProto.isUnknownType();
 unknown=true;
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:25:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+unknown=implicitProto.isUnknownType();
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:25:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+unknown=implicitProto.isUnknownType();
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
-unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:25:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||implicitProto.isNativeObjectType()||"".equals(implicitProto==null)){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:25:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if(implicitProto==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:25:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(unknown!=true){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/529/pattern-ver1-serial/src.com.crankcode.threads.MediaThread.java-end.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:25:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(true){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:25:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||implicitProto.isNativeObjectType()&&unknown){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2749/pattern-ver1-serial/Stuyablo.java-combat.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:26:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||implicitProto.isNativeObjectType()==false){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:26:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
+if(interfaceType.getClass().getSimpleName().startsWith("SystemException")){
+return true;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:26:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if(implicitProto.getClass().getSimpleName().startsWith("SystemException")){
+return true;
+}
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:26:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+if(implicitProto.getClass().getSimpleName().startsWith("SystemException")){
+return true;
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:26:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(unknown&&(implicitProto==null||implicitProto.isNativeObjectType())){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:26:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||implicitProto.isNativeObjectType()||unknown){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:26:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/1184/pattern-ver1-serial/swagplash.src.main.java.com.github.albertosh.swagplash.actions.ApiBodyParamAction.java-call.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:26:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/6852/pattern-ver1-serial/vipr-portal.portal.app.controllers.tenant.TenantSelector.java-renderTenantOptionsForVcenters.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:27:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null||implicitProto.isNativeObjectType()==true){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:27:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(unknown){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/7120/pattern-ver1-serial/app.src.main.java.com.codephillip.intmain.fitracer.MainActivity.java-run.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:27:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto!=null&&(implicitProto==null||implicitProto.isNativeObjectType())){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V10/668/pattern-ver1-serial/opencga-catalog.src.main.java.org.opencb.opencga.catalog.models.Status.java-isValid.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:27:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
+if(implicitProto==null){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
+if(interfaceType.isUnknownType()&&implicitProto.isNativeObjectType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V21/4076/pattern-ver1-serial/moho-impl.src.main.java.com.voxeo.moho.sip.DirectAI2NOJoinDelegate.java-doInviteResponse.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:27:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
+for(int i=0;i<24;i++){
 unknown=true;
+}
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/7063/pattern-ver1-serial/src.application.rmi.Serveur.java-initalisationMain.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:27:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+for(int i=0;i<24;i++){
 unknown=implicitProto.isUnknownType();
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/7063/pattern-ver1-serial/src.application.rmi.Serveur.java-initalisationMain.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:27:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+for(int i=0;i<24;i++){
 unknown=false;
+}
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/7063/pattern-ver1-serial/src.application.rmi.Serveur.java-initalisationMain.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:27:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+boolean atLeastOneNonProhibited=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
+atLeastOneNonProhibited=true;
 break;
+}
 }
+if(atLeastOneNonProhibited){
+throw new IllegalStateException("There should be a vertex satisfying these properties, but there is not, so there must be something wrong..");
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4655/pattern-ver1-serial/src.Alg.Algorithms.IterativeCompression.SimpleDisjointAlg.java-findVertexWithOneNonProhibitedNeighbour.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:28:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+boolean atLeastOneNonProhibited=false;
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
+atLeastOneNonProhibited=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
+if(atLeastOneNonProhibited){
+throw new IllegalStateException("There should be a vertex satisfying these properties, but there is not, so there must be something wrong..");
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4655/pattern-ver1-serial/src.Alg.Algorithms.IterativeCompression.SimpleDisjointAlg.java-findVertexWithOneNonProhibitedNeighbour.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:28:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+boolean atLeastOneNonProhibited=false;
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+atLeastOneNonProhibited=true;
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
+if(atLeastOneNonProhibited){
+throw new IllegalStateException("There should be a vertex satisfying these properties, but there is not, so there must be something wrong..");
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4655/pattern-ver1-serial/src.Alg.Algorithms.IterativeCompression.SimpleDisjointAlg.java-findVertexWithOneNonProhibitedNeighbour.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:28:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+boolean atLeastOneNonProhibited=false;
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+atLeastOneNonProhibited=true;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
+if(atLeastOneNonProhibited){
+throw new IllegalStateException("There should be a vertex satisfying these properties, but there is not, so there must be something wrong..");
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4655/pattern-ver1-serial/src.Alg.Algorithms.IterativeCompression.SimpleDisjointAlg.java-findVertexWithOneNonProhibitedNeighbour.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:28:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
+boolean atLeastOneNonProhibited=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
+atLeastOneNonProhibited=true;
 }
+if(atLeastOneNonProhibited){
+throw new IllegalStateException("There should be a vertex satisfying these properties, but there is not, so there must be something wrong..");
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4655/pattern-ver1-serial/src.Alg.Algorithms.IterativeCompression.SimpleDisjointAlg.java-findVertexWithOneNonProhibitedNeighbour.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:28:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+boolean atLeastOneNonProhibited=false;
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+atLeastOneNonProhibited=true;
+}
+if(atLeastOneNonProhibited){
+throw new IllegalStateException("There should be a vertex satisfying these properties, but there is not, so there must be something wrong..");
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4655/pattern-ver1-serial/src.Alg.Algorithms.IterativeCompression.SimpleDisjointAlg.java-findVertexWithOneNonProhibitedNeighbour.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:28:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+synchronized(this){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
+}
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:28:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
-unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/5667/pattern-ver1-serial/src.AccessorBean.java-onPageLoaded.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 8, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:28:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
+long startTime=System.currentTimeMillis();
 unknown=implicitProto.isUnknownType();
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:29:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+long startTime=System.currentTimeMillis();
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:29:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+long startTime=System.currentTimeMillis();
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:29:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
+long startTime=System.currentTimeMillis();
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }else {
 unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:29:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
-unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
-unknown=true;
-break;
-}
-}
-}else {
 unknown=implicitProto.isUnknownType();
+}else {
+unknown=true;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5622/pattern-ver1-serial/src.main.java.com.github.randoapp.adapter.RandoPairsAdapter.java-initData.pattern
MATCHLEVEL : ALL
ALL : 15, UPD : 15, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:29:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
-unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
-unknown=true;
-break;
-}
-}
-}else {
 unknown=implicitProto.isUnknownType();
+}else {
+unknown=false;
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5622/pattern-ver1-serial/src.main.java.com.github.randoapp.adapter.RandoPairsAdapter.java-initData.pattern
MATCHLEVEL : ALL
ALL : 15, UPD : 15, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:29:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
+if(implicitProto==null||implicitProto.isNativeObjectType()){
+unknown=false;
+for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+if(interfaceType.isUnknownType()){
+unknown=true;
+break;
+}
+}
+}else {
+unknown=implicitProto.isUnknownType();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V11/5689/pattern-ver1-serial/minecraft.net.minecraft.src.BlockCocoaSapling.java-blockActivated.pattern
MATCHLEVEL : ALL
ALL : 22, UPD : 0, INS : 1, DEL : 21
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:29:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
+synchronized(this){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 24, UPD : 24, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:29:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
-ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
-}
 }
-}else {
-unknown=implicitProto.isUnknownType();
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/3709/pattern-ver1-serial/src.main.java.jfxtras.labs.scene.layout.GridPane.java-apply.pattern
MATCHLEVEL : ALL
ALL : 24, UPD : 24, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:30:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
 if(unknown){
 ObjectType implicitProto=getImplicitPrototype();
 if(implicitProto==null||implicitProto.isNativeObjectType()){
 unknown=false;
 for(ObjectType interfaceType : getCtorExtendedInterfaces()){
 if(interfaceType.isUnknownType()){
 unknown=true;
 break;
 }
 }
 }else {
 unknown=implicitProto.isUnknownType();
+}
+}else {
+unknown=false;
+for(ObjectType interfaceType : getCtorExtendedInterfaces()){
+if(interfaceType.isUnknownType()){
+unknown=true;
+break;
+}
 }
 }
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2011/V2/2933/pattern-ver1-serial/common.common-io.src.main.java.com.twelvemonkeys.io.AbstractCachedSeekableStream.java-seekImpl.pattern
MATCHLEVEL : ALL
ALL : 24, UPD : 24, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:30:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/rhino/jstype/ObjectType.java[560,584]
------------Candidate---------------
 @Override public boolean isUnknownType(){
-if(unknown){
-ObjectType implicitProto=getImplicitPrototype();
-if(implicitProto==null||implicitProto.isNativeObjectType()){
-unknown=false;
-for(ObjectType interfaceType : getCtorExtendedInterfaces()){
-if(interfaceType.isUnknownType()){
-unknown=true;
-break;
-}
-}
-}else {
-unknown=implicitProto.isUnknownType();
-}
-}
 return unknown;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 25, UPD : 0, INS : 0, DEL : 25
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 06:30:17 CDT
--------------- END -----------------
Location : com.google.javascript.jscomp.TypeCheck.checkInterfaceConflictProperties:[1570, 1574, 1575, 1576, 1577, 1578, 1580, 1586, 1587, 1588, 1589, 1591, 1592]#1.0
Compute Candidate : 2019.09.10 AD at 06:32:07 CDT - 2019.09.10 AD at 07:23:08 CDT , PNumber : 11394, CandNumber : 570 
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:23:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:23:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:23:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:23:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
+return ;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:23:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/4557/pattern-ver1-serial/src.de.rincewind.api.gui.elements.ElementCounter.java-setCount.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:23:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+continue;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:24:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+continue;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:24:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+continue;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:24:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+continue;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/5856/pattern-ver1-serial/internalLibraries.backup.src.main.java.com.emc.storageos.management.backup.DbBackupHandler.java-dumpBackup.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:24:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+return ;
 }
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/1404/pattern-ver1-serial/src.controllers.AnimatedBorderPane.java-setRightAnimated.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:24:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V9/323/pattern-ver1-serial/PhysicsEngine.src.de.engine.colldetect.ContactCreator.java-getCirclePolygonContact.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:24:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
-ObjectType implicitProto=interfaceType.getImplicitPrototype();
+ ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:24:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:24:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString(),null));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V11/3756/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.block.ScaleIOMaskingOrchestrator.java-exportGroupAddInitiators.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:25:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),null,interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/7021/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.isilon.IsilonFileStorageDevice.java-doCreateFS.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:25:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(oType==null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/1240/pattern-ver1-serial/flexo-foundation.src.main.java.org.openflexo.foundation.viewpoint.FlexoConceptInstanceRole.java-applyValidation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:25:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+currentPropertyNames=implicitProto.getOwnPropertyNames();
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:25:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+break;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:25:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+break;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:25:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+break;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:25:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+break;
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:26:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!implicitProto.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V58/3430/pattern-ver1-serial/org.eclipse.jdt.core.compiler.org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.java-inferFunctionalInterfaceParameterization.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:26:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(implicitProto.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/554/pattern-ver1-serial/src.main.java.ledger.io.input.DuplicateDetector.java-compare.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:26:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1324/pattern-ver1-serial/cspi-schema.src.main.java.org.collectionspace.chain.csp.schema.Record.java-getServicesTenantDoctype.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:26:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ObjectType oType=properties.remove(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/2156/pattern-ver1-serial/src.server.Server.java-addScheduledFailure.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:26:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
-currentProperties.put(name,interfaceType);
+currentProperties.putIfAbsent(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5128/pattern-ver1-serial/mbhd-core.src.main.java.org.multibit.hd.core.services.WalletService.java-addTransactionInfo.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:26:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,currentPropertyNames.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V43/3712/pattern-ver1-serial/src.com.wrathOfLoD.Models.Entity.Character.Character.java-Character.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:26:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),currentPropertyNames.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V43/3712/pattern-ver1-serial/src.com.wrathOfLoD.Models.Entity.Character.Character.java-Character.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:26:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(implicitProto!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:27:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(name!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:27:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(functionName!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:27:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(n!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:27:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(t!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:27:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(interfaceType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:27:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(properties!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:27:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(currentProperties!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:27:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(currentPropertyNames!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/1150/pattern-ver1-serial/src.main.java.de.nedelosk.modularmachines.client.gui.GuiAssembler.java-onUpdate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:28:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+currentPropertyNames=implicitProto.getOwnPropertyNames();
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/3884/pattern-ver1-serial/TcpChat.src.client.gui.ClientGuiThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:28:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+currentPropertyNames=implicitProto.getOwnPropertyNames();
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/3884/pattern-ver1-serial/TcpChat.src.client.gui.ClientGuiThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:28:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+currentPropertyNames=implicitProto.getOwnPropertyNames();
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/3884/pattern-ver1-serial/TcpChat.src.client.gui.ClientGuiThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:28:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+currentPropertyNames=implicitProto.getOwnPropertyNames();
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/3884/pattern-ver1-serial/TcpChat.src.client.gui.ClientGuiThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:28:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
-currentProperties.put(name,interfaceType);
+currentProperties.remove(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/1469/pattern-ver1-serial/transport-native-epoll.src.main.java.io.netty.jni.channel.AbstractEpollChannel.java-doDeregister.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:28:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),implicitProto.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/2230/pattern-ver1-serial/src.com.ichi2.anki.DeckTask.java-doInBackgroundSaveDeck.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:28:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
-ObjectType implicitProto=interfaceType.getImplicitPrototype();
-Set<String> currentPropertyNames;
+ final ObjectType implicitProto=interfaceType.getImplicitPrototype();
+ final Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:28:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
-ObjectType implicitProto=interfaceType.getImplicitPrototype();
+ final ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ final ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:29:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
-Set<String> currentPropertyNames;
+ final Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ final ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:29:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
-ObjectType implicitProto=interfaceType.getImplicitPrototype();
-Set<String> currentPropertyNames;
+ ObjectType implicitProto=interfaceType.getImplicitPrototype();
+ Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:29:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
-Set<String> currentPropertyNames;
+ Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:29:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
+import java.util.regex.Pattern;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ObjectType oType=properties.get(name.trim());
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/7877/pattern-ver1-serial/src.com.genomen.ui.cli.ArgumentProcessor.java-parseRequiredSamples.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:29:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
+import java.util.regex.Pattern;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name.trim()).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/7877/pattern-ver1-serial/src.com.genomen.ui.cli.ArgumentProcessor.java-parseRequiredSamples.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:29:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
+import java.util.regex.Pattern;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name.trim()))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/7877/pattern-ver1-serial/src.com.genomen.ui.cli.ArgumentProcessor.java-parseRequiredSamples.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:29:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.isEmpty()){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:29:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.isEmpty()){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:30:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.isEmpty()){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:30:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.isEmpty()){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:30:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n.isEmpty()){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:30:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(properties.isEmpty()){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:30:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(currentProperties.isEmpty()){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:30:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.isEmpty()){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:30:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.TreeSet;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(n.isEmpty()){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/1891/pattern-ver1-serial/src.jp.ac.osaka_u.ist.sdl.prevol.db.retriever.MethodDataRetriever.java-retrieveInSpecifiedFiles.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:30:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(currentPropertyNames.isEmpty()){
+return ;
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V35/2729/pattern-ver1-serial/davinci.src.main.java.cn.hadcn.davinci.image.DiskLruImageCache.java-getBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:31:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+currentPropertyNames.clear();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V41/6396/pattern-ver1-serial/core.src.com.FOS.Pixel.screens.GameScreen.java-checkCollectedOrbs.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:31:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+synchronized(this){
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:31:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+synchronized(currentProperties){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/90/pattern-ver1-serial/PolibudaRun.src.HorizontalMove.java-down.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:31:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+synchronized(compiler){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/90/pattern-ver1-serial/PolibudaRun.src.HorizontalMove.java-down.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:31:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+properties.clear();
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/5987/pattern-ver1-serial/src.org.kjg.garderobe.ShiftDetailNumbersFragment.java-onCreateOptionsMenu.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:31:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+currentProperties.clear();
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/5987/pattern-ver1-serial/src.org.kjg.garderobe.ShiftDetailNumbersFragment.java-onCreateOptionsMenu.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:31:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+properties.clear();
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5052/pattern-ver1-serial/proxy.src.main.java.com.xqbase.tuna.proxy.ProxyServer.java-returnClient.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:32:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+currentProperties.clear();
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5052/pattern-ver1-serial/proxy.src.main.java.com.xqbase.tuna.proxy.ProxyServer.java-returnClient.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:32:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
-currentPropertyNames=implicitProto.getOwnPropertyNames();
+currentPropertyNames=null;
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/2637/pattern-ver1-serial/de.bund.bfr.knime.openkrise.views.src.de.bund.bfr.knime.openkrise.views.gisgraphview.GraphSettings.java-GraphSettings.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:32:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ObjectType oType=properties.get((name).toLowerCase());
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2032/pattern-ver1-serial/src.main.ContaminationDialog.java-onOK.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:32:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType((name).toLowerCase()).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2032/pattern-ver1-serial/src.main.ContaminationDialog.java-onOK.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:32:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType((name).toLowerCase()))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2032/pattern-ver1-serial/src.main.ContaminationDialog.java-onOK.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:32:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+synchronized(this){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:32:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+synchronized(this){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+}
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:32:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
+if(equals(interfaceType)){
+return ;
+}
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:33:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(equals(name)){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:33:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(equals(name)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:33:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(equals(interfaceType)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:33:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(equals(interfaceType)){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:33:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(equals(n)){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:33:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(equals(interfaceType)){
+return ;
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:33:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(equals(t)){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:34:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
+if(equals(n)){
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:34:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+break;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+break;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/1550/pattern-ver1-serial/src.com.patr.radix.ActiveTimeActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:34:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+while(true){
+
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:34:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+while(true){
+
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:34:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+while(true){
+
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:34:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+}
+while(true){
+
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:34:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+while(true){
+
+}
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:35:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name.isEmpty()){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/3182/pattern-ver1-serial/canal-client.src.main.java.com.tqmall.search.canal.handle.TableSectionHandle.java-runRowChangeAction.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:35:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+break;
 }
 currentProperties.put(name,interfaceType);
+break;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1968/pattern-ver1-serial/src.main.java.com.ucmo.chat.controller.Controller.java-handleMessage.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:35:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+break;
 }
 }
 currentProperties.put(name,interfaceType);
+break;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1968/pattern-ver1-serial/src.main.java.com.ucmo.chat.controller.Controller.java-handleMessage.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:35:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+break;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+break;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1968/pattern-ver1-serial/src.main.java.com.ucmo.chat.controller.Controller.java-handleMessage.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:35:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+synchronized(this){
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:35:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+if(functionName.isEmpty()){
+return ;
+}
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/6812/pattern-ver1-serial/src.main.java.wslf.homemoviebase.logic.Worker.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:35:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(functionName.isEmpty()){
+return ;
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/6812/pattern-ver1-serial/src.main.java.wslf.homemoviebase.logic.Worker.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:35:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ObjectType oType=properties.get((name).toUpperCase());
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7401/pattern-ver1-serial/Model.src.main.java.config.SensorParams.java-SensorParams.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:36:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType((name).toUpperCase()).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7401/pattern-ver1-serial/Model.src.main.java.config.SensorParams.java-SensorParams.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:36:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType((name).toUpperCase()))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7401/pattern-ver1-serial/Model.src.main.java.config.SensorParams.java-SensorParams.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:36:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:36:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name==null){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:36:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(functionName==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:36:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(name==null){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:36:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(n==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:36:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(t==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:37:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(interfaceType==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:37:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(properties==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:37:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(currentProperties==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:37:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(functionName==null){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:37:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name==null){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:37:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name==null){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:37:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:38:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:38:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(t==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:38:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:38:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Solution---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+if(implicitProto==null){
+return ;
+}
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:40:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(n==null){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:40:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(t==null){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:40:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(iType==null){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V1/5906/pattern-ver1-serial/src.com.apocalyptech.minecraft.xray.MineCraftEnvironment.java-buildImageFromInput.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:40:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:40:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(currentPropertyNames==null){
+return ;
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:40:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5764/pattern-ver1-serial/SmartTrader.app.src.main.java.com.loveboyuan.smarttrader.InventoryActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:41:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+if(currentProperties!=null){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6555/pattern-ver1-serial/app.src.main.java.com.example.uaharoni.tourdeplace.view.MapFragment.java-addPlaceMarker.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:41:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(compiler!=null){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6555/pattern-ver1-serial/app.src.main.java.com.example.uaharoni.tourdeplace.view.MapFragment.java-addPlaceMarker.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:41:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString())!=null){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/262/pattern-ver1-serial/src.internal.tree.WorldTree.java-getAllChildren.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:41:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Solution---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+if(implicitProto!=null){
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/6354/pattern-ver1-serial/src.cager.jexpr.visitor.BoogieVisitor.java-visitPrimaryExpression.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:43:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(properties==currentProperties){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3923/pattern-ver1-serial/railo-java.railo-core.src.railo.runtime.op.Operator.java-_equalsComplexEL.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:43:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
+if(interfaceType==null){
+return ;
+}
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:43:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Solution---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+if(implicitProto==null){
+return ;
+}
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:45:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(currentProperties==null){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:45:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(properties==null){
+return ;
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:45:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(oType==null){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:45:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
+if(implicitProto==interfaceType.getImplicitPrototype()){
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:46:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(implicitProto==interfaceType.getImplicitPrototype()){
+return ;
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:46:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+}
+if(implicitProto==interfaceType.getImplicitPrototype()){
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:46:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
+if(currentPropertyNames==null){
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:46:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(name==null){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:46:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(interfaceType==null){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:46:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+currentPropertyNames.add("bookmark");
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/3527/pattern-ver1-serial/src.commandHelp.CommandList.java-cmds.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:46:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(oType.equals(null)){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/343/pattern-ver1-serial/src.gui.batches.ItemBatchView.java-selectProduct.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:47:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString())==null){
+continue;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/816/pattern-ver1-serial/src.main.java.com.dynious.refinedrelocation.client.renderer.RendererRelocator.java-renderTileEntityAt.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:47:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if("index".equals(name)){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:47:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if("index".equals(name)){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:47:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if("index".equals(name)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:47:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if("index".equals(functionName)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:47:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if("index".equals(functionName)){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:47:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if("index".equals(functionName)){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:47:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if("index".equals(n)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:48:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if("index".equals(t)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:48:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if("index".equals(interfaceType)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:48:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if("index".equals(properties)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:48:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equals("TIME")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:48:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.equals("TIME")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:48:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.equals("TIME")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:48:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.equals("TIME")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:49:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.equals("TIME")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:49:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(functionName.equals("TIME")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:49:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n.equals("TIME")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:49:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(t.equals("TIME")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:49:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(interfaceType.equals("TIME")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:49:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(properties.equals("TIME")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:49:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if("&null".equals(name)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:49:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if("&null".equals(name)){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:50:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if("&null".equals(functionName)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:50:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if("&null".equals(name)){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:50:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if("&null".equals(n)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:50:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if("&null".equals(t)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:50:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if("&null".equals(interfaceType)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:50:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if("&null".equals(properties)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:50:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if("&null".equals(currentProperties)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:51:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if("&null".equals(functionName)){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:51:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType==null){
+continue;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/ui.src.main.java.thredds.ui.monitor.MultipleAxisChart.java-finish.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:51:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(name.equals("DATETIME")){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:51:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name.equals("DATETIME")){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:51:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name.equals("DATETIME")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:51:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(functionName.equals("DATETIME")){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:51:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(functionName.equals("DATETIME")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:51:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(functionName.equals("DATETIME")){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:52:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(n.equals("DATETIME")){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:52:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(t.equals("DATETIME")){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:52:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(interfaceType.equals("DATETIME")){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:52:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(properties.equals("DATETIME")){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:52:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
-ObjectType implicitProto=interfaceType.getImplicitPrototype();
-Set<String> currentPropertyNames;
+ final ObjectType implicitProto=interfaceType.getImplicitPrototype();
+ final Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ final ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/1483/pattern-ver1-serial/core.src.de.homelab.madgaksha.lotsofbs.cutscenesystem.fancyscene.FancyZoom.java-readNextObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:52:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(compiler==null){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2437/pattern-ver1-serial/app.src.main.java.org.gdg.frisbee.android.onboarding.FirstStartStep1Fragment.java-addChapters.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:52:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
-ObjectType implicitProto=interfaceType.getImplicitPrototype();
-Set<String> currentPropertyNames;
+ @SuppressWarnings("UnusedAssignment") ObjectType implicitProto=interfaceType.getImplicitPrototype();
+ @SuppressWarnings("UnusedAssignment") Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ @SuppressWarnings("UnusedAssignment") ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:53:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+name=name;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:53:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+functionName=name;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:53:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
+if(interfaceType.getCtorExtendedInterfaces()!=null){
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+}
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1943/pattern-ver1-serial/app.src.main.java.br.com.battista.myoffers.controller.OfferController.java-saveOfferInDatabase.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:53:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(currentPropertyNames!=null){
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1943/pattern-ver1-serial/app.src.main.java.br.com.battista.myoffers.controller.OfferController.java-saveOfferInDatabase.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:53:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+if(implicitProto.equals("")){
+return ;
+}
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/6228/pattern-ver1-serial/src.engine.QueryEngine.java-slice.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:53:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(currentPropertyNames.equals("")){
+return ;
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/6228/pattern-ver1-serial/src.engine.QueryEngine.java-slice.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:53:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType.equals("")){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/6228/pattern-ver1-serial/src.engine.QueryEngine.java-slice.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:53:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+currentPropertyNames.remove(null);
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/4839/pattern-ver1-serial/runtime.src.main.java.com.flipkart.flux.resource.StateMachineResource.java-getGraphData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:54:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+currentPropertyNames.add("PLOTTERsizeMethodMix");
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V18/3254/pattern-ver1-serial/src.fileProcessing.ConfReader.java-ConfReader.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:54:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(true){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:54:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+if(interfaceType!=null){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/6062/pattern-ver1-serial/src.main.java.org.openarchives.resourcesync.ResourceSyncDescription.java-addCapabilityList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:54:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+currentPropertyNames.add(functionName);
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/6056/pattern-ver1-serial/fr.inria.soctrace.tools.ocelotl.ui.src.fr.inria.soctrace.tools.ocelotl.ui.loaders.ConfDataLoader.java-getTypes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:54:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+if(implicitProto.equals("-1")){
+return ;
+}
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:54:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType.equals("-1")){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:54:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(currentPropertyNames.equals("-1")){
+return ;
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:55:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+if(name!=null){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V43/991/pattern-ver1-serial/CEO.src.cs2103.CommandParser.java-separateParameters.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:55:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(name.contains("deviantart.com")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/4166/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.ContentType.java-getImageType.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:55:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name.contains("deviantart.com")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/4166/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.ContentType.java-getImageType.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:55:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(name.contains("deviantart.com")){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/4166/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.ContentType.java-getImageType.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:55:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(functionName.contains("deviantart.com")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/4166/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.ContentType.java-getImageType.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:55:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(functionName.contains("deviantart.com")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/4166/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.ContentType.java-getImageType.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:55:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+currentPropertyNames.add(name);
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/4847/pattern-ver1-serial/capsule-generation.src.main.java.org.paninij.runtime.check.Panini.java-findUnsafe.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:55:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+currentPropertyNames.add(name);
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/4847/pattern-ver1-serial/capsule-generation.src.main.java.org.paninij.runtime.check.Panini.java-findUnsafe.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:56:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+int a=0;
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:56:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+int a=0;
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:56:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+int a=0;
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:56:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+int a=0;
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:56:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
+int a=0;
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:56:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equals(n)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:56:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n.equals(name)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:56:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equals(t)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:57:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equals(functionName)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:57:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n.equals(t)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:57:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n.equals(functionName)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:57:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(t.equals(name)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:57:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(t.equals(n)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:57:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equals(interfaceType)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:57:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n.equals(interfaceType)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:58:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+String OUTSTRING="";
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:58:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+String OUTSTRING="";
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:58:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+String OUTSTRING="";
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:58:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
+String OUTSTRING="";
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:58:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+String OUTSTRING="";
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:58:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+currentPropertyNames.add(name);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V10/3832/pattern-ver1-serial/src.miningChanges.ObtainVSMScore.java-updateCorpusNL.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:58:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import com.google.common.base.Strings;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ObjectType oType=properties.get(Strings.nullToEmpty(name));
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/5967/pattern-ver1-serial/src.main.java.com.threebird.recorder.models.sessions.SessionManager.java-therapistProperty.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:58:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import com.google.common.base.Strings;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(Strings.nullToEmpty(name)).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/5967/pattern-ver1-serial/src.main.java.com.threebird.recorder.models.sessions.SessionManager.java-therapistProperty.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:59:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import com.google.common.base.Strings;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(Strings.nullToEmpty(name)))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/5967/pattern-ver1-serial/src.main.java.com.threebird.recorder.models.sessions.SessionManager.java-therapistProperty.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:59:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+int compiler=5;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/7018/pattern-ver1-serial/app.src.main.java.com.priteshjain.popularmovies.util.EndlessRecyclerOnScrollListener.java-onScrolled.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:59:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.Reader;
+
+import java.io.InputStream;
+
+import java.io.InputStreamReader;
+
+import java.io.OutputStreamWriter;
+
+import java.io.IOException;
+
+import java.io.OutputStream;
+
+import java.io.Writer;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(interfaceType.equals(InputStream.class)){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1916/pattern-ver1-serial/ambari-server.src.main.java.org.apache.ambari.server.api.GsonJsonProvider.java-readFrom.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:59:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.startsWith("-")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/3084/pattern-ver1-serial/src.cdio.shared.FieldVerifier.java-isValidRbId.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:59:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.startsWith("-")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/3084/pattern-ver1-serial/src.cdio.shared.FieldVerifier.java-isValidRbId.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:59:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.startsWith("-")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/3084/pattern-ver1-serial/src.cdio.shared.FieldVerifier.java-isValidRbId.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 07:59:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.startsWith("-")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/3084/pattern-ver1-serial/src.cdio.shared.FieldVerifier.java-isValidRbId.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:00:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.startsWith("-")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/3084/pattern-ver1-serial/src.cdio.shared.FieldVerifier.java-isValidRbId.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:00:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.startsWith("extern ")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/100/pattern-ver1-serial/plugins.org.nitlanguage.ndt.src.org.nitlanguage.ndt.ui.docmodel.Declaration.java-removeModificatorKeyword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:00:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.startsWith("extern ")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/100/pattern-ver1-serial/plugins.org.nitlanguage.ndt.src.org.nitlanguage.ndt.ui.docmodel.Declaration.java-removeModificatorKeyword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:00:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.startsWith("extern ")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/100/pattern-ver1-serial/plugins.org.nitlanguage.ndt.src.org.nitlanguage.ndt.ui.docmodel.Declaration.java-removeModificatorKeyword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:00:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.startsWith("extern ")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/100/pattern-ver1-serial/plugins.org.nitlanguage.ndt.src.org.nitlanguage.ndt.ui.docmodel.Declaration.java-removeModificatorKeyword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:00:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.startsWith("extern ")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/100/pattern-ver1-serial/plugins.org.nitlanguage.ndt.src.org.nitlanguage.ndt.ui.docmodel.Declaration.java-removeModificatorKeyword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:00:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(functionName.startsWith("extern ")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/100/pattern-ver1-serial/plugins.org.nitlanguage.ndt.src.org.nitlanguage.ndt.ui.docmodel.Declaration.java-removeModificatorKeyword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:00:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:01:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:01:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:01:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:01:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:01:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+int indexSelection=0;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:01:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+int indexSelection=0;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:01:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+int indexSelection=0;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:02:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+int indexSelection=0;
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:02:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+int indexSelection=0;
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:02:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+name="";
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1830/pattern-ver1-serial/SR03.src.java.controler.ActionQuestion.java-doGet.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:02:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(name.equals("setPackMode")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/2611/pattern-ver1-serial/app.src.main.java.com.example.kristian.ideacreator.IdeasContentProvider.java-call.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:02:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(name.equals("sounds")){
+continue;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:02:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name.equals("sounds")){
+continue;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:02:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(functionName.equals("sounds")){
+continue;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:03:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(interfaceType.equals("sounds")){
+continue;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:03:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(interfaceType.equals("sounds")){
+continue;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:03:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(currentProperties.equals("sounds")){
+continue;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:03:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(n.equals("sounds")){
+continue;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:03:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(t.equals("sounds")){
+continue;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:03:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equals("sounds")){
+continue;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:03:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.startsWith("https")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/6342/pattern-ver1-serial/src.main.java.org.spo.fw.web.Lib_Utils.java-alterGotoUrl.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:03:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.startsWith("https")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/6342/pattern-ver1-serial/src.main.java.org.spo.fw.web.Lib_Utils.java-alterGotoUrl.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:04:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.startsWith("https")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/6342/pattern-ver1-serial/src.main.java.org.spo.fw.web.Lib_Utils.java-alterGotoUrl.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:04:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.startsWith("https")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/6342/pattern-ver1-serial/src.main.java.org.spo.fw.web.Lib_Utils.java-alterGotoUrl.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:04:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.startsWith("https")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/6342/pattern-ver1-serial/src.main.java.org.spo.fw.web.Lib_Utils.java-alterGotoUrl.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:04:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+int a=1;
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:04:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+int a=1;
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:04:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+int a=1;
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:04:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+int a=1;
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:05:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
+int a=1;
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:05:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equalsIgnoreCase("/")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/3102/pattern-ver1-serial/src.main.java.com.github.kongchen.swagger.docgen.reader.AbstractReader.java-parseOperationPath.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:05:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.equalsIgnoreCase("/")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/3102/pattern-ver1-serial/src.main.java.com.github.kongchen.swagger.docgen.reader.AbstractReader.java-parseOperationPath.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:05:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.equalsIgnoreCase("/")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/3102/pattern-ver1-serial/src.main.java.com.github.kongchen.swagger.docgen.reader.AbstractReader.java-parseOperationPath.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:05:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.equalsIgnoreCase("/")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/3102/pattern-ver1-serial/src.main.java.com.github.kongchen.swagger.docgen.reader.AbstractReader.java-parseOperationPath.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:05:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.equalsIgnoreCase("/")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/3102/pattern-ver1-serial/src.main.java.com.github.kongchen.swagger.docgen.reader.AbstractReader.java-parseOperationPath.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:05:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+boolean INCOMPATIBLE_EXTENDED_PROPERTY_TYPE=true;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V29/4636/pattern-ver1-serial/core.src.io.github.emergentorganization.cellrpg.input.player.MovementControls.PathDraw.java-process.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:05:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+boolean b=true;
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:06:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+boolean b=true;
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:06:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+boolean b=true;
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:06:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+boolean b=true;
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:06:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
+boolean b=true;
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:06:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equalsIgnoreCase("")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/3403/pattern-ver1-serial/src.Primitives.Stemmer.java-step4.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:06:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.equalsIgnoreCase("")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/3403/pattern-ver1-serial/src.Primitives.Stemmer.java-step4.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:06:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.equalsIgnoreCase("")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/3403/pattern-ver1-serial/src.Primitives.Stemmer.java-step4.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:06:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.equalsIgnoreCase("")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/3403/pattern-ver1-serial/src.Primitives.Stemmer.java-step4.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:07:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.equalsIgnoreCase("")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/3403/pattern-ver1-serial/src.Primitives.Stemmer.java-step4.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:07:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.awt.List;
+
+import java.util.*;
+
+import java.awt.geom.Arc2D;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+if(implicitProto.equals(null)){
+return ;
+}
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V40/2100/pattern-ver1-serial/ExpressionCalculator.ExpressionCalculator.java-recursiveReduce.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:07:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.awt.List;
+
+import java.util.*;
+
+import java.awt.geom.Arc2D;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType.equals(null)){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V40/2100/pattern-ver1-serial/ExpressionCalculator.ExpressionCalculator.java-recursiveReduce.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:07:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name==null){
+continue;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:07:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name==null){
+continue;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:07:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null){
+continue;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:07:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n==null){
+continue;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(t==null){
+continue;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName==null){
+continue;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(n==null){
+continue;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(t==null){
+continue;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.matches("[0-9]*")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/5036/pattern-ver1-serial/src.engine.PrinterServerTask1After.java-checkIfInputMatchStored.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.matches("[0-9]*")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/5036/pattern-ver1-serial/src.engine.PrinterServerTask1After.java-checkIfInputMatchStored.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.matches("[0-9]*")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/5036/pattern-ver1-serial/src.engine.PrinterServerTask1After.java-checkIfInputMatchStored.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.matches("[0-9]*")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/5036/pattern-ver1-serial/src.engine.PrinterServerTask1After.java-checkIfInputMatchStored.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:08:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.matches("[0-9]*")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/5036/pattern-ver1-serial/src.engine.PrinterServerTask1After.java-checkIfInputMatchStored.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:09:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if((Thread.currentThread().interrupted())){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:09:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if((Thread.currentThread().interrupted())){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:09:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if((Thread.currentThread().interrupted())){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:09:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+if((Thread.currentThread().interrupted())){
+return ;
+}
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:09:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+if((Thread.currentThread().interrupted())){
+return ;
+}
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:09:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(0>=currentProperties.size()){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V7/5077/pattern-ver1-serial/src.Utils.Helper.java-getModeInt.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:09:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+if(currentProperties.size()>0){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/506/pattern-ver1-serial/app.src.main.java.com.jessie.guessnumber.MainActivity.java-delete.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:10:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()).equals("")){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/60/pattern-ver1-serial/app.src.main.java.com.holygon.dishcuss.Fragments.AccountPhotosFragment.java-SetImageURL.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:10:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+assert (name!=null);
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:10:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (name!=null);
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:10:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+assert (name!=null);
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:10:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (functionName!=null);
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:10:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (n!=null);
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:10:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (t!=null);
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:10:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (interfaceType!=null);
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:11:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (properties!=null);
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:11:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+assert (functionName!=null);
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:11:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (currentProperties!=null);
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:11:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (!name.isEmpty());
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:11:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+assert (!name.isEmpty());
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:11:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+assert (!name.isEmpty());
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:11:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (!functionName.isEmpty());
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:11:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+assert (!functionName.isEmpty());
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:12:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+assert (!functionName.isEmpty());
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:12:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (!n.isEmpty());
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:12:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (!properties.isEmpty());
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:12:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
+if(interfaceType!=null){
+ObjectType implicitProto=interfaceType.getImplicitPrototype();
+Set<String> currentPropertyNames;
+currentPropertyNames=implicitProto.getOwnPropertyNames();
+for(String name : currentPropertyNames){
+ObjectType oType=properties.get(name);
+if(oType!=null){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+}
+currentProperties.put(name,interfaceType);
+}
+for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+}
+}
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:12:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(interfaceType!=null){
+ObjectType oType=properties.get(name);
+if(oType!=null){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+}
+currentProperties.put(name,interfaceType);
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:12:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name!=null){
+ObjectType oType=properties.get(name);
+if(oType!=null){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+}
+currentProperties.put(name,interfaceType);
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:12:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name!=null){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:13:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(properties!=null){
+ObjectType oType=properties.get(name);
+if(oType!=null){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+}
+currentProperties.put(name,interfaceType);
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:13:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ObjectType oType=properties.get(name.trim());
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name.trim()).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/7016/pattern-ver1-serial/ClassApplication.src.main.java.com.exam.ViewExamAnsAction.java-performBaseAction.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:13:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
-ObjectType oType=properties.get(name);
+ObjectType oType=properties.get(name.trim());
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name.trim()))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/7016/pattern-ver1-serial/ClassApplication.src.main.java.com.exam.ViewExamAnsAction.java-performBaseAction.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:13:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name.trim()).isEquivalentTo(oType.getPropertyType(name.trim()))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/7016/pattern-ver1-serial/ClassApplication.src.main.java.com.exam.ViewExamAnsAction.java-performBaseAction.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:13:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+assert (implicitProto!=interfaceType.getImplicitPrototype());
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:13:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (oType!=properties.get(name));
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:13:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+assert (oType!=null);
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:13:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:14:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:14:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:14:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(t.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:14:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:14:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:14:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(interfaceType.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:14:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(properties.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:15:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(currentProperties.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:15:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(n.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:15:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+assert (n!=null);
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/126/pattern-ver1-serial/main.table.org.gamegineer.table.core.src.org.gamegineer.table.core.ComponentPath.java-compareTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:15:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.isEmpty()){
+System.out.println("Team has to have a name");
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/1672/pattern-ver1-serial/cli.src.main.java.cz.muni.fi.pa165.fast.cli.TeamCreateCommand.java-argument.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:15:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name.isEmpty()){
+System.out.println("Team has to have a name");
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/1672/pattern-ver1-serial/cli.src.main.java.cz.muni.fi.pa165.fast.cli.TeamCreateCommand.java-argument.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:15:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.isEmpty()){
+System.out.println("Team has to have a name");
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/1672/pattern-ver1-serial/cli.src.main.java.cz.muni.fi.pa165.fast.cli.TeamCreateCommand.java-argument.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:15:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(functionName.isEmpty()){
+System.out.println("Team has to have a name");
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/1672/pattern-ver1-serial/cli.src.main.java.cz.muni.fi.pa165.fast.cli.TeamCreateCommand.java-argument.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:15:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(n.isEmpty()){
+System.out.println("Team has to have a name");
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/1672/pattern-ver1-serial/cli.src.main.java.cz.muni.fi.pa165.fast.cli.TeamCreateCommand.java-argument.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:16:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (n!=null);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:16:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (t!=null);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:16:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (interfaceType!=null);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:16:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+assert (name!=null);
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:16:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+assert (name!=null);
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:16:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+assert (name!=null);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:16:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+assert (n!=null);
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:16:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+assert (n!=null);
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:17:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+if(!currentProperties.containsKey(name)){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V39/7615/pattern-ver1-serial/src.mudmap2.backend.World.java-put.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:17:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+if(implicitProto.equals("655")){
+System.out.println();
+}
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3726/pattern-ver1-serial/src.protosocket.client.WriteThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:17:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType.equals("655")){
+System.out.println();
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3726/pattern-ver1-serial/src.protosocket.client.WriteThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:17:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(oType!=null||"".equals(oType)){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:17:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+currentProperties.put(name,interfaceType);
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:17:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+currentProperties.put(name,interfaceType);
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
-currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:17:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+currentProperties.put(name,interfaceType);
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
-currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:18:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+currentProperties.put(name,interfaceType);
 }
 }
-currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:18:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
-}
 }
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:18:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+currentProperties.put(name,interfaceType);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:18:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+currentProperties.put(name,interfaceType);
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:18:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+currentProperties.put(name,interfaceType);
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:18:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name.isEmpty()){
+name=null;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:18:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name.isEmpty()){
+name=null;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:19:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(name.isEmpty()){
+name=null;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:19:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(functionName.isEmpty()){
+functionName=null;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:19:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(n.isEmpty()){
+n=null;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:19:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(properties.isEmpty()){
+properties=null;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:19:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(currentProperties.isEmpty()){
+currentProperties=null;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:19:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(functionName.isEmpty()){
+functionName=null;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:19:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+currentProperties.put(name,interfaceType);
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/2451/pattern-ver1-serial/ShopNow.src.shopnow.Customer_Account.java-get_phone_number.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:19:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+currentProperties.put(name,interfaceType);
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:20:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(name.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:20:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(n.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:20:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:20:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(t.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:20:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(functionName.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:20:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(interfaceType.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:20:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(name.getClass().getSimpleName().startsWith("SystemException")){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:21:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(properties.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:21:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(currentProperties.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:21:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(n.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:21:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:21:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:21:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:21:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:21:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:22:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(oType!=null||oType==null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/4704/pattern-ver1-serial/src.main.java.com.alibaba.fastjson.parser.ParserConfig.java-createJavaBeanDeserializer.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:22:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType==null?null:oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/4299/pattern-ver1-serial/client.synapseJavaClient.src.main.java.org.sagebionetworks.client.SynapseClientImpl.java-uploadToS3FileHandle.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:22:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType!=null?oType.getPropertyType(name):null)){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/4302/pattern-ver1-serial/src.com.floreantpos.model.KitchenTicket.java-fromTicket.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:22:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:22:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:22:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:22:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:22:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:23:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+assert (name!=null):"Appointments day is not allowed to be null!";
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:23:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+assert (name!=null):"Appointments day is not allowed to be null!";
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:23:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+assert (implicitProto!=null):"Appointments day is not allowed to be null!";
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:23:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (name!=null):"Appointments day is not allowed to be null!";
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:23:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (n!=null):"Appointments day is not allowed to be null!";
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:23:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (t!=null):"Appointments day is not allowed to be null!";
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:23:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+assert (functionName!=null):"Appointments day is not allowed to be null!";
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:24:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+assert (n!=null):"Appointments day is not allowed to be null!";
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:24:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+assert (t!=null):"Appointments day is not allowed to be null!";
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:24:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.util.HashSet;
+
+import java.util.Collections;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
+if(properties.isEmpty()){
+properties=null;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/6949/pattern-ver1-serial/app.src.main.java.com.peprally.jeremy.peprally.db_models.DBUserProfile.java-removeConversationId.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:24:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.isEmpty()){
+throw new IllegalArgumentException("Title must not be empty!");
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/1109/pattern-ver1-serial/eclipse.src.stoberry.dataManagement.Management.java-sendMessage.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:24:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name.isEmpty()){
+throw new IllegalArgumentException("Title must not be empty!");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/1109/pattern-ver1-serial/eclipse.src.stoberry.dataManagement.Management.java-sendMessage.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:24:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(name.isEmpty()){
+throw new IllegalArgumentException("Title must not be empty!");
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/1109/pattern-ver1-serial/eclipse.src.stoberry.dataManagement.Management.java-sendMessage.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:24:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(functionName.isEmpty()){
+throw new IllegalArgumentException("Title must not be empty!");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/1109/pattern-ver1-serial/eclipse.src.stoberry.dataManagement.Management.java-sendMessage.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:24:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+currentProperties.put(name,interfaceType);
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:25:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(properties==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:25:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:25:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(interfaceType==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:25:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(currentProperties==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:25:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(t==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:25:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(compiler==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:25:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(interfaceType.getPropertyType(name)==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:26:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null){
+throw new IllegalStateException("Cannot instantiate Page whitout String url constructor parameter or @PageURL class annotation");
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4732/pattern-ver1-serial/src.main.java.com.mgiorda.page.AbstractPage.java-AbstractPage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:26:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name==null){
+throw new IllegalStateException("Cannot instantiate Page whitout String url constructor parameter or @PageURL class annotation");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4732/pattern-ver1-serial/src.main.java.com.mgiorda.page.AbstractPage.java-AbstractPage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:26:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString())==null){
+throw new IllegalStateException("Cannot instantiate Page whitout String url constructor parameter or @PageURL class annotation");
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4732/pattern-ver1-serial/src.main.java.com.mgiorda.page.AbstractPage.java-AbstractPage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:26:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+currentPropertyNames.add("intervalBetweenShocks");
+currentPropertyNames.add("fisherEpsilon");
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V46/2153/pattern-ver1-serial/tetrad-lib.src.main.java.edu.cmu.tetrad.algcomparison.simulation.LeeHastieSimulation.java-getParameters.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:26:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(functionName==null){
+return ;
+}
+if(name==null){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:26:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName==null){
+return ;
+}
+if(name==null){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:26:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName==null){
+return ;
+}
+if(name==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:26:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(n==null){
+return ;
+}
+if(name==null){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:27:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(t==null){
+return ;
+}
+if(name==null){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:27:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(n==null){
+return ;
+}
+if(name==null){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:27:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(interfaceType==null){
+return ;
+}
+if(name==null){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:27:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(t==null){
+return ;
+}
+if(name==null){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:27:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.equals("CALL_RECEIVED_AT")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(name.equals("NAME")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:27:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.equals("CALL_RECEIVED_AT")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name.equals("NAME")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:27:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.equals("CALL_RECEIVED_AT")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(name.equals("NAME")){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:28:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.equals("CALL_RECEIVED_AT")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(functionName.equals("NAME")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:28:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.equals("CALL_RECEIVED_AT")){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(functionName.equals("NAME")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:28:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(functionName.equals("CALL_RECEIVED_AT")){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(functionName.equals("NAME")){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:28:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(n.equals("CALL_RECEIVED_AT")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(n.equals("NAME")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:28:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(t.equals("CALL_RECEIVED_AT")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(t.equals("NAME")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:28:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(interfaceType.equals("CALL_RECEIVED_AT")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(interfaceType.equals("NAME")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:28:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(properties.equals("CALL_RECEIVED_AT")){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(properties.equals("NAME")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:28:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(oType!=null&&!oType.equals("")){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/6260/pattern-ver1-serial/Client.src.com.way.chat.activity.ChatActivity.java-onItemClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:29:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(name.equals("INFO")){
+return ;
+}
+if(name.equals("UNIT")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:29:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name.equals("INFO")){
+return ;
+}
+if(name.equals("UNIT")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:29:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(name.equals("INFO")){
+return ;
+}
+if(name.equals("UNIT")){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:29:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(functionName.equals("INFO")){
+return ;
+}
+if(functionName.equals("UNIT")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:29:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(functionName.equals("INFO")){
+return ;
+}
+if(functionName.equals("UNIT")){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:29:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(functionName.equals("INFO")){
+return ;
+}
+if(functionName.equals("UNIT")){
+return ;
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:29:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(n.equals("INFO")){
+return ;
+}
+if(n.equals("UNIT")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:30:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(t.equals("INFO")){
+return ;
+}
+if(t.equals("UNIT")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:30:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(interfaceType.equals("INFO")){
+return ;
+}
+if(interfaceType.equals("UNIT")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:30:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(properties.equals("INFO")){
+return ;
+}
+if(properties.equals("UNIT")){
+return ;
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4313/pattern-ver1-serial/cadpage-parsers.src.main.java.net.anei.cadpage.parsers.VA.VAAlbemarleCountyCParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:30:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+if(interfaceType!=null&&name!=null){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/523/pattern-ver1-serial/src.se.chalmers.lidkopingsh.model.Order.java-sync.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:30:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
+if(implicitProto==null||currentPropertyNames==null){
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/3334/pattern-ver1-serial/src.org.nschmidt.ldparteditor.data.VM03Adjacency.java-linkedCommonFaces.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 7, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:30:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+}
+if(implicitProto==null||currentPropertyNames==null){
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/3334/pattern-ver1-serial/src.org.nschmidt.ldparteditor.data.VM03Adjacency.java-linkedCommonFaces.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 7, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:30:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+if(currentProperties!=null){
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V62/5851/pattern-ver1-serial/src.main.java.com.dynious.refinedrelocation.grid.GridMemberHandler.java-onTileRemoved.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 3, INS : 0, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:30:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name!=null){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
-currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5356/pattern-ver1-serial/src.main.java.it.istc.cnr.stlab.clodg.quality.AnalyseNames.java-extractCoauthorsForAuthor.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 3, INS : 0, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:31:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(currentPropertyNames!=null&&!currentPropertyNames.isEmpty()){
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V35/5236/pattern-ver1-serial/src.main.java.cc.hunter.killua.entity.KilluaUser.java-getAuthorities.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:31:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(currentProperties!=null){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
-currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/5497/pattern-ver1-serial/app.src.main.java.hm.orz.chaos114.android.tumekyouen.TitleActivity.java-afterViews.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 3, INS : 0, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:31:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+if(currentProperties!=null){
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/5497/pattern-ver1-serial/app.src.main.java.hm.orz.chaos114.android.tumekyouen.TitleActivity.java-afterViews.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 3, INS : 0, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:31:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(!properties.isEmpty()){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
-currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/251/pattern-ver1-serial/src.focus.up.DAO.java-removeBroadcast.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 3, INS : 0, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:31:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
+if(implicitProto==null){
+throw new IllegalStateException("User isn't registered! "+interfaceType);
+}
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:31:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType==null){
+throw new IllegalStateException("User isn't registered! "+name);
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:31:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType==null){
+throw new IllegalStateException("User isn't registered! "+properties);
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:31:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+if(currentPropertyNames==null){
+throw new IllegalStateException("User isn't registered! "+implicitProto);
+}
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:32:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(interfaceType.getPropertyType(name)!=null&&!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/4226/pattern-ver1-serial/src.main.java.org.walkmod.javalang.walkers.ChangeLogVisitor.java-visit.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:32:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/6908/pattern-ver1-serial/mainModule.src.backend.building.ProductionBuilding.java-canBuild.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:32:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(true){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:32:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))==false){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:32:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))&&false){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/5079/pattern-ver1-serial/Server.src.server.model.players.packets.ClickNPC.java-processPacket.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:32:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/4215/pattern-ver1-serial/Mage.Server.src.main.java.mage.server.TableController.java-joinTournament.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:32:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(interfaceType.getPropertyType(name)!=null){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/2504/pattern-ver1-serial/app.src.main.java.com.projectmanagement.benson.homeinventoryapp.Models.List.java-setKeys.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:33:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.startsWith("\r\n")){
+name=name.substring(2);
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:33:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(name.startsWith("\r\n")){
+name=name.substring(2);
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:33:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name.startsWith("\r\n")){
+name=name.substring(2);
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:33:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName.startsWith("\r\n")){
+functionName=functionName.substring(2);
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:33:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(functionName.startsWith("\r\n")){
+functionName=functionName.substring(2);
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:33:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(name.startsWith("/")){
+name=name.substring(1);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:33:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name.startsWith("/")){
+name=name.substring(1);
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:33:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+if(name.startsWith("/")){
+name=name.substring(1);
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:34:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+if(functionName.startsWith("/")){
+functionName=functionName.substring(1);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:34:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(functionName.startsWith("/")){
+functionName=functionName.substring(1);
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:34:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(interfaceType!=null&&!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V26/6745/pattern-ver1-serial/collectors.http.src.main.java.com.groupon.lex.metrics.collector.httpget.UrlGetCollector.java-get_http_client_.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:34:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))==true){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:34:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean succeeded=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+succeeded=true;
+}
+if(!succeeded){
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V58/1711/pattern-ver1-serial/code.mettle.app.org.mef.framework.utils.ResourceReader.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:34:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean succeeded=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+succeeded=true;
 }
 currentProperties.put(name,interfaceType);
+}
+if(!succeeded){
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V58/1711/pattern-ver1-serial/code.mettle.app.org.mef.framework.utils.ResourceReader.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:34:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean succeeded=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+succeeded=true;
 }
 }
 currentProperties.put(name,interfaceType);
+}
+if(!succeeded){
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V58/1711/pattern-ver1-serial/code.mettle.app.org.mef.framework.utils.ResourceReader.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:35:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean succeeded=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
+if(!succeeded){
+return ;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+succeeded=true;
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V58/1711/pattern-ver1-serial/code.mettle.app.org.mef.framework.utils.ResourceReader.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:35:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.length()==2){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+if(name.length()==1){
+return ;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/6820/pattern-ver1-serial/src.main.java.org.asciidoc.intellij.actions.asciidoc.SimpleFormatAsciiDocAction.java-removeSymbol.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:35:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name.length()==1){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(name.length()==2){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/6820/pattern-ver1-serial/src.main.java.org.asciidoc.intellij.actions.asciidoc.SimpleFormatAsciiDocAction.java-removeSymbol.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:35:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(name.length()==1){
+return ;
+}
 if(oType!=null){
+if(name.length()==2){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/6820/pattern-ver1-serial/src.main.java.org.asciidoc.intellij.actions.asciidoc.SimpleFormatAsciiDocAction.java-removeSymbol.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:35:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(functionName.length()==1){
+return ;
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(functionName.length()==2){
+return ;
+}
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/6820/pattern-ver1-serial/src.main.java.org.asciidoc.intellij.actions.asciidoc.SimpleFormatAsciiDocAction.java-removeSymbol.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:35:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(functionName.length()==1){
+return ;
+}
 if(oType!=null){
+if(functionName.length()==2){
+return ;
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/6820/pattern-ver1-serial/src.main.java.org.asciidoc.intellij.actions.asciidoc.SimpleFormatAsciiDocAction.java-removeSymbol.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:35:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean haveBreadCrumbs=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
-if(oType!=null){
+if(oType!=null&&haveBreadCrumbs){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+haveBreadCrumbs=true;
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:35:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(functionName==null||n==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:36:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(functionName==null||t==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:36:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(functionName==null||iType==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:36:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(functionName==null||properties==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:36:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(functionName==null||currentProperties==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:36:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(n==null||t==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:36:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(n==null||functionName==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:36:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(t==null||n==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:37:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(n==null||iType==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:37:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+if(iType==null||n==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:37:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+compiler.report(t==null?null:t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/4299/pattern-ver1-serial/client.synapseJavaClient.src.main.java.org.sagebionetworks.client.SynapseClientImpl.java-uploadToS3FileHandle.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:37:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+compiler.report(t!=null?t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()):null);
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/4302/pattern-ver1-serial/src.com.floreantpos.model.KitchenTicket.java-fromTicket.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:37:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(name.endsWith("/")==false){
+name=name+"/";
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/627/pattern-ver1-serial/src.main.java.com.thunder.util.Util.java-restMap.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:37:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(functionName.endsWith("/")==false){
+functionName=functionName+"/";
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/627/pattern-ver1-serial/src.main.java.com.thunder.util.Util.java-restMap.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:37:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||n==null||interfaceType==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:37:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||t==null||interfaceType==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:38:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||functionName==null||interfaceType==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:38:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||properties==null||interfaceType==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:38:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||t==null||n==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:38:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||functionName==null||n==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:38:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||n==null||t==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:38:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||n==null||functionName==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:38:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||t==null||functionName==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:38:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null||functionName==null||t==null){
+return ;
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:39:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean haveBreadCrumbs=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))&&haveBreadCrumbs){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 8, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:39:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+synchronized(this){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:39:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(functionName==null){
+functionName="20160101";
+}
+if(name==null){
+name="20200101";
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V11/5352/pattern-ver1-serial/GitlabMonitor.src.main.java.org.gitmining.monitor.service.StudentService.java-getStudentEventItem.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:39:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(name==null){
+name="20160101";
+}
+if(functionName==null){
+functionName="20200101";
+}
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V11/5352/pattern-ver1-serial/GitlabMonitor.src.main.java.org.gitmining.monitor.service.StudentService.java-getStudentEventItem.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:39:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:39:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:39:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:39:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:40:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:40:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:40:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:40:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:40:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+try{
 currentProperties.put(name,interfaceType);
+}finally{
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 1, INS : 0, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:40:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
-compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/5656/pattern-ver1-serial/Project1.src.com.example.project1.EditTextModified.java-onSelectionChanged.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:40:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+long startTime=System.currentTimeMillis();
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:41:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+long startTime=System.currentTimeMillis();
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:41:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+long startTime=System.currentTimeMillis();
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:41:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
+long startTime=System.currentTimeMillis();
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:41:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
+long startTime=System.currentTimeMillis();
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:41:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean haveBreadCrumbs=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))&&haveBreadCrumbs){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+haveBreadCrumbs=true;
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 8, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:41:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean haveBreadCrumbs=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))&&haveBreadCrumbs){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+haveBreadCrumbs=true;
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 8, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:41:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+boolean haveBreadCrumbs=false;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))&&haveBreadCrumbs){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
+haveBreadCrumbs=true;
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 8, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:41:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
+if(compiler!=null){
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V62/5851/pattern-ver1-serial/src.main.java.com.dynious.refinedrelocation.grid.GridMemberHandler.java-onTileRemoved.pattern
MATCHLEVEL : ALL
ALL : 15, UPD : 3, INS : 0, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:42:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
-currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V1/3556/pattern-ver1-serial/src.net.tootallnate.websocket.WebSocketClient.java-close.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 12, INS : 0, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:42:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+if(!(currentProperties.get(name)==interfaceType)){
 currentProperties.put(name,interfaceType);
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V18/1854/pattern-ver1-serial/src.main.java.eu.spitfire_project.smart_service_proxy.core.httpServer.EntityManager.java-virtualEntityCreated.pattern
MATCHLEVEL : ALL
ALL : 18, UPD : 6, INS : 0, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:42:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+synchronized(this){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 20, UPD : 20, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:42:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
+}else {
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 20, UPD : 20, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:42:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
-if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
-}
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2729/pattern-ver1-serial/Spykes.CloudVision.app.src.main.java.inovation.lab.cloudvision.Speech.java-onInit.pattern
MATCHLEVEL : ALL
ALL : 20, UPD : 20, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:42:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
+if(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString())!=null){
+if(currentProperties!=null){
 currentProperties.put(name,interfaceType);
+}
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/7882/pattern-ver1-serial/RaspiMediaCenter.src.raspimediacenter.Logic.Utilities.ScraperUtils.java-scraperParseAlbum.pattern
MATCHLEVEL : ALL
ALL : 20, UPD : 8, INS : 0, DEL : 12
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:42:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 21, UPD : 0, INS : 1, DEL : 20
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:42:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 21, UPD : 0, INS : 1, DEL : 20
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:43:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 21, UPD : 0, INS : 1, DEL : 20
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:43:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
+if(properties!=null){
 ObjectType oType=properties.get(name);
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/258/pattern-ver1-serial/web.src.main.java.com.epam.freelancer.web.controller.UserController.java-addIsComplaintInOrderings.pattern
MATCHLEVEL : ALL
ALL : 23, UPD : 3, INS : 0, DEL : 20
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:43:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1554,1592]
------------Candidate---------------
 private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
 ObjectType implicitProto=interfaceType.getImplicitPrototype();
 Set<String> currentPropertyNames;
 currentPropertyNames=implicitProto.getOwnPropertyNames();
 for(String name : currentPropertyNames){
 ObjectType oType=properties.get(name);
+if(oType!=null){
+if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
+compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
 if(oType!=null){
 if(!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))){
 compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
+}
+}
 }
 }
 currentProperties.put(name,interfaceType);
 }
 for(ObjectType iType : interfaceType.getCtorExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V18/1214/pattern-ver1-serial/src.main.java.cz.vutbr.web.domassign.SingleMapNodeData.java-toString.pattern
MATCHLEVEL : ALL
ALL : 24, UPD : 0, INS : 1, DEL : 23
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 08:43:30 CDT
--------------- END -----------------
Location : com.google.javascript.jscomp.TypeCheck.visitFunction:[1658, 1660, 1662, 1663, 1664, 1647, 1653, 1646, 1656, 1602, 1603, 1604, 1605, 1606, 1609, 1613, 1614, 1615, 1616, 1618, 1619, 1624, 1625, 1626, 1627, 1628, 1630, 1632, 1634, 1635, 1637, 1638, 1640, 1642, 1644, 1649, 1666, 1667, 1670]#1.0
Compute Candidate : 2019.09.10 AD at 08:45:30 CDT - 2019.09.10 AD at 10:31:40 CDT , PNumber : 9662, CandNumber : 647 
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+return ;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+return ;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
+return ;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+return ;
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+return ;
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
+return ;
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+return ;
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
+return ;
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+return ;
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+return ;
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V41/1695/pattern-ver1-serial/src.fr.project.bluechat.layout.activity.MainActivity.java-newName.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+return ;
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V41/1695/pattern-ver1-serial/src.fr.project.bluechat.layout.activity.MainActivity.java-newName.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
+return ;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V1/2057/pattern-ver1-serial/multiplication-game.Main.java-ollie.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
+return ;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V1/2057/pattern-ver1-serial/multiplication-game.Main.java-ollie.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
+return ;
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+return ;
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
+return ;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
+return ;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/3473/pattern-ver1-serial/src.main.java.com.fabegabe.cmd.CCCommand.java-onCommand.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
+return ;
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5432/pattern-ver1-serial/app.src.main.java.com.rrdevs.peerboard.DBCompare.java-authenticateLogin.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+continue;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+continue;
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+continue;
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
+continue;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
+continue;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+continue;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/5856/pattern-ver1-serial/internalLibraries.backup.src.main.java.com.emc.storageos.management.backup.DbBackupHandler.java-dumpBackup.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
+return ;
 }
 }else {
 badImplementedType=true;
+return ;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/2908/pattern-ver1-serial/edu.usc.cssl.tacit.topicmodel.lda.ui.src.edu.usc.cssl.tacit.topicmodel.lda.ui.LdaTopicModelView.java-run.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+continue;
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/7695/pattern-ver1-serial/docroot.WEB-INF.src.com.jorgediaz.missingrefchecker.MissingReferences.java-execute.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
-String functionPrivateName=n.getFirstChild().getString();
+ String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
-FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
+ FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+ ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
+ boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>=1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/3225/pattern-ver1-serial/src.org.peg4d.ParserContext.java-beginPeformStat.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor==null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/1240/pattern-ver1-serial/flexo-foundation.src.main.java.org.openflexo.foundation.viewpoint.FlexoConceptInstanceRole.java-applyValidation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if(interfaceConstructor==null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/1240/pattern-ver1-serial/flexo-foundation.src.main.java.org.openflexo.foundation.viewpoint.FlexoConceptInstanceRole.java-applyValidation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
+if(baseInterfaceObj==null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/1240/pattern-ver1-serial/flexo-foundation.src.main.java.org.openflexo.foundation.viewpoint.FlexoConceptInstanceRole.java-applyValidation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+break;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+break;
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+break;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+break;
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
+break;
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/1233/pattern-ver1-serial/crm.src.main.java.com.ogg.crm.ui.activity.CustomerPublicListActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
+properties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/668/pattern-ver1-serial/src.jp.ac.aiit.jointry.controllers.MainController.java-initialize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface.getConstructor()==null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/2545/pattern-ver1-serial/kennedy-langlotz.KLQ.src.com.klq.ast.ParseTreeConverter.java-visitUncondQuestion.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+break;
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2900/pattern-ver1-serial/BlueMesh.src.blue.mesh.ServerThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
+break;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2027/pattern-ver1-serial/cong.Internet.BRITE.src.org.cong.complexNetwork.model.AB.java-getTargetNode.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
+break;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2027/pattern-ver1-serial/cong.Internet.BRITE.src.org.cong.complexNetwork.model.AB.java-getTargetNode.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface.getConstructor()!=null==!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/5945/pattern-ver1-serial/app.src.main.java.me.diskstation.ammon.gpsrunner.ui.CalendarFragment.java-onActionItemClicked.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null==baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/5945/pattern-ver1-serial/app.src.main.java.me.diskstation.ammon.gpsrunner.ui.CalendarFragment.java-onActionItemClicked.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()!=1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/71/pattern-ver1-serial/src.edu.stanford.nlp.mt.decoder.feat.base.TranslationModelFeaturizer.java-ruleFeaturize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
-if(badImplementedType){
+if(true){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor==getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/2266/pattern-ver1-serial/core.src.com.collidge.MyGdxGame.java-keyUp.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(baseConstructor==getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/2266/pattern-ver1-serial/core.src.com.collidge.MyGdxGame.java-keyUp.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>3){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5511/pattern-ver1-serial/core.src.com.trumandeyoung.sprouts.GameRenderer.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if(interfaceConstructor!=null==!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V67/427/pattern-ver1-serial/softwaresystems.src.ss.week5.Board.java-isFull.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+ObjectType proto=functionType.getPrototype();
+if(functionType.makesStructs()&&!proto.isStruct()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+}else {
+if(functionType.makesDicts()&&!proto.isDict()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
+}
+}
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V26/1681/pattern-ver1-serial/src.edu.umn.cs.melt.copper.compiletime.srcbuilders.single.ParserFragmentEngineBuilder.java-writeRunProductionSemanticAction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
+currentProperties.toString();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/7441/pattern-ver1-serial/HelloWorld.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface.toString()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/7441/pattern-ver1-serial/HelloWorld.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
-String functionPrivateName=n.getFirstChild().getString();
+String functionPrivateName=n.getFirstChild().toString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/1640/pattern-ver1-serial/spring-social-vkontakte.src.main.java.org.springframework.social.vkontakte.api.impl.WallTemplate.java-getPost.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&n!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&t!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
+functionType.isInterface();
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6189/pattern-ver1-serial/src.Connection.java-discoverIP.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
+functionType.isInterface();
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6189/pattern-ver1-serial/src.Connection.java-discoverIP.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
+functionType.isInterface();
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6189/pattern-ver1-serial/src.Connection.java-discoverIP.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface.getConstructor()!=null&&!extInterface.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5764/pattern-ver1-serial/SmartTrader.app.src.main.java.com.loveboyuan.smarttrader.InventoryActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
-String functionPrivateName=n.getFirstChild().getString();
+String functionPrivateName=n.getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5764/pattern-ver1-serial/SmartTrader.app.src.main.java.com.loveboyuan.smarttrader.InventoryActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ final ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
-String functionPrivateName=n.getFirstChild().getString();
+ final String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ final FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ final FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+ final ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
-FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
+ final FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
-String functionPrivateName=n.getFirstChild().getString();
+ String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+ ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
-FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
+ FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
+ boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ final FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/4668/pattern-ver1-serial/src.main.java.accountService.AccountServiceImpl.java-updateUser.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
-if(functionType.isConstructor()){
+if(!functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/6908/pattern-ver1-serial/mainModule.src.backend.building.ProductionBuilding.java-canBuild.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
+if(!functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/6908/pattern-ver1-serial/mainModule.src.backend.building.ProductionBuilding.java-canBuild.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties.isEmpty()){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n.isEmpty()){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties.isEmpty()){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/3286/pattern-ver1-serial/DatabaseMSCore.src.DatabaseMSCore.dbTypeInteger.java-canBeInitializedWith.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.TreeSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(n.isEmpty()){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/1891/pattern-ver1-serial/src.jp.ac.osaka_u.ist.sdl.prevol.db.retriever.MethodDataRetriever.java-retrieveInSpecifiedFiles.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(currentProperties.isEmpty()){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/4707/pattern-ver1-serial/src.main.java.org.jboss.pressgang.ccms.contentspec.processor.ContentSpecProcessor.java-processExistingTopicTags.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
+if(functionPrivateName.isEmpty()){
+return ;
+}
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V9/386/pattern-ver1-serial/Voikko.src.main.java.fi.nationallibrary.ndl.solrvoikko.VoikkoFilter.java-incrementToken.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
-if(functionType.isConstructor()){
+if(true){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
+if(true){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(n.isEmpty()){
+return ;
+}
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V10/7235/pattern-ver1-serial/core.src.main.java.org.nextprot.api.core.dao.impl.DbXrefDaoImpl.java-findDbXRefByPublicationIds.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
+if(n.isEmpty()){
+return ;
+}
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V10/7235/pattern-ver1-serial/core.src.main.java.org.nextprot.api.core.dao.impl.DbXrefDaoImpl.java-findDbXRefByPublicationIds.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+properties.clear();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V41/6396/pattern-ver1-serial/core.src.com.FOS.Pixel.screens.GameScreen.java-checkCollectedOrbs.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+currentProperties.clear();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V41/6396/pattern-ver1-serial/core.src.com.FOS.Pixel.screens.GameScreen.java-checkCollectedOrbs.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
+synchronized(this){
 badImplementedType=true;
+}
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+synchronized(currentProperties){
 currentProperties.clear();
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/90/pattern-ver1-serial/PolibudaRun.src.HorizontalMove.java-down.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+synchronized(properties){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/90/pattern-ver1-serial/PolibudaRun.src.HorizontalMove.java-down.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+synchronized(compiler){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/90/pattern-ver1-serial/PolibudaRun.src.HorizontalMove.java-down.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+properties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/5987/pattern-ver1-serial/src.org.kjg.garderobe.ShiftDetailNumbersFragment.java-onCreateOptionsMenu.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties.isEmpty()){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5856/pattern-ver1-serial/src.main.java.io.aif.associations.builder.ExperimentsConnectionsGraphReducer.java-normalize.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+properties.clear();
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5052/pattern-ver1-serial/proxy.src.main.java.com.xqbase.tuna.proxy.ProxyServer.java-returnClient.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+synchronized(this){
 currentProperties.clear();
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+synchronized(this){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+synchronized(this){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(equals(extInterface)){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(properties.isEmpty()){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/5123/pattern-ver1-serial/src.main.java.org.mcstats.generator.ReflectionAggregator.java-getValues.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
+if(properties.isEmpty()){
+return ;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/5123/pattern-ver1-serial/src.main.java.org.mcstats.generator.ReflectionAggregator.java-getValues.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties.isEmpty()){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7204/pattern-ver1-serial/src.main.java.sg.edu.nus.cs2103t.omnitask.logic.DataImpl.java-addTask.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/1150/pattern-ver1-serial/src.main.java.de.nedelosk.modularmachines.client.gui.GuiAssembler.java-onUpdate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(t!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/1150/pattern-ver1-serial/src.main.java.de.nedelosk.modularmachines.client.gui.GuiAssembler.java-onUpdate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(n!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/1150/pattern-ver1-serial/src.main.java.de.nedelosk.modularmachines.client.gui.GuiAssembler.java-onUpdate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+while(true){
+
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+while(true){
+
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
+while(true){
+
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+while(true){
+
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
+while(true){
+
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
 }
+while(true){
+
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+while(true){
+
+}
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+}
+while(true){
+
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
+while(true){
+
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+}
+while(true){
+
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if((functionType.makesStructs())&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/4601/pattern-ver1-serial/core.src.by.matveev.rorty.entities.Robot.java-updateControlState.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if((functionType.makesDicts())&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/4601/pattern-ver1-serial/core.src.by.matveev.rorty.entities.Robot.java-updateControlState.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
+break;
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+break;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1968/pattern-ver1-serial/src.main.java.com.ucmo.chat.controller.Controller.java-handleMessage.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+break;
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+break;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1968/pattern-ver1-serial/src.main.java.com.ucmo.chat.controller.Controller.java-handleMessage.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+break;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+break;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1968/pattern-ver1-serial/src.main.java.com.ucmo.chat.controller.Controller.java-handleMessage.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties==null){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(properties==null){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(n==null){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(t==null){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(interfaceType==null){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+if(n==null){
+return ;
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+if(t==null){
+return ;
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+if(n==null){
+return ;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+if(t==null){
+return ;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/244/pattern-ver1-serial/app.src.main.java.net.pilpin.nanodegree_popularmovies.FetchMoviesTask.java-getDataFromJsonMovieList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties==null){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n==null){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType==null){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5349/pattern-ver1-serial/drools-wb-screens.drools-wb-guided-dtable-editor.drools-wb-guided-dtable-editor-client.src.main.java.org.drools.workbench.screens.guided.dtable.client.widget.table2.columns.dom.textbox.TextBoxLongSingletonDOMElementFactory.java-convert.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(currentProperties==null){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
+if(baseConstructor==null){
+return ;
+}
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+if(baseInterfaceObj==null){
+return ;
+}
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V18/3545/pattern-ver1-serial/server.src.main.java.nl.inl.blacklab.server.requesthandlers.SearchParameters.java-docSortSettings.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties!=null){
 currentProperties.clear();
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6555/pattern-ver1-serial/app.src.main.java.com.example.uaharoni.tourdeplace.view.MapFragment.java-addPlaceMarker.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties!=null){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6555/pattern-ver1-serial/app.src.main.java.com.example.uaharoni.tourdeplace.view.MapFragment.java-addPlaceMarker.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
+if(validator!=null){
 validator.expectAllInterfaceProperties(t,n,functionType);
+}
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6555/pattern-ver1-serial/app.src.main.java.com.example.uaharoni.tourdeplace.view.MapFragment.java-addPlaceMarker.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties!=currentProperties){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/7075/pattern-ver1-serial/app.src.main.java.com.gustavoparreira.realtimetile.Player.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties!=null){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/262/pattern-ver1-serial/src.internal.tree.WorldTree.java-getAllChildren.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName)!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/262/pattern-ver1-serial/src.internal.tree.WorldTree.java-getAllChildren.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName)!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+}
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/262/pattern-ver1-serial/src.internal.tree.WorldTree.java-getAllChildren.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(compiler!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/3708/pattern-ver1-serial/mifosng-android.src.main.java.com.mifos.mifosxdroid.online.ClientListFragment.java-onCreateView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.Collection;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
+if(proto==null){
+return ;
+}
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/3593/pattern-ver1-serial/velvetdb-mapdb.src.main.java.com.zakgof.db.velvet.mapdb.MapDbVelvet.java-isBelow.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.Collection;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+if(interfaceConstructor==null){
+return ;
+}
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/3593/pattern-ver1-serial/velvetdb-mapdb.src.main.java.com.zakgof.db.velvet.mapdb.MapDbVelvet.java-isBelow.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties==currentProperties){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3923/pattern-ver1-serial/railo-java.railo-core.src.railo.runtime.op.Operator.java-_equalsComplexEL.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties==properties){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3923/pattern-ver1-serial/railo-java.railo-core.src.railo.runtime.op.Operator.java-_equalsComplexEL.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(functionType==null){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
 }
+if(functionType==null){
+return ;
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
+if(functionType==null){
+return ;
+}
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
+if(functionType==null){
+return ;
+}
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+}
+if(baseConstructor==functionType.getSuperClassConstructor()){
+return ;
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties==null){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties==null){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(currentProperties==null){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(n==null){
+return ;
+}
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
+if(baseInterfaceObj.equals(null)){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/343/pattern-ver1-serial/src.gui.batches.ItemBatchView.java-selectProduct.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+synchronized(this){
 badImplementedType=true;
+}
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties==null){
+continue;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/816/pattern-ver1-serial/src.main.java.com.dynious.refinedrelocation.client.renderer.RendererRelocator.java-renderTileEntityAt.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if("index".equals(properties)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if("index".equals(properties)){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if("index".equals(n)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if("index".equals(t)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if("index".equals(interfaceType)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if("index".equals(n)){
+return ;
+}
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if("index".equals(t)){
+return ;
+}
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if("index".equals(functionPrivateName)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if("index".equals(n)){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties.equals("TIME")){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties.equals("TIME")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n.equals("TIME")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(t.equals("TIME")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType.equals("TIME")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(n.equals("TIME")){
+return ;
+}
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(t.equals("TIME")){
+return ;
+}
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(n.equals("TIME")){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(t.equals("TIME")){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4918/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MI.MIMobileMedicalResponseParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if("&null".equals(properties)){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if("&null".equals(n)){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if("&null".equals(t)){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if("&null".equals(interfaceType)){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
+if("&null".equals(n)){
+return ;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
+if("&null".equals(n)){
+return ;
+}
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties.equals("DATETIME")){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(properties.equals("DATETIME")){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(n.equals("DATETIME")){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(t.equals("DATETIME")){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(interfaceType.equals("DATETIME")){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+if(n.equals("DATETIME")){
+return ;
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+if(t.equals("DATETIME")){
+return ;
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+if(n.equals("DATETIME")){
+return ;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.util.regex.Matcher;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+if(t.equals("DATETIME")){
+return ;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6302/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.MO.MOWarrenCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ final ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/1483/pattern-ver1-serial/core.src.de.homelab.madgaksha.lotsofbs.cutscenesystem.fancyscene.FancyZoom.java-readNextObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
-FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
+ final FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/1483/pattern-ver1-serial/core.src.de.homelab.madgaksha.lotsofbs.cutscenesystem.fancyscene.FancyZoom.java-readNextObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ final FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/1483/pattern-ver1-serial/core.src.de.homelab.madgaksha.lotsofbs.cutscenesystem.fancyscene.FancyZoom.java-readNextObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ final FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/1483/pattern-ver1-serial/core.src.de.homelab.madgaksha.lotsofbs.cutscenesystem.fancyscene.FancyZoom.java-readNextObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+ final ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/1483/pattern-ver1-serial/core.src.de.homelab.madgaksha.lotsofbs.cutscenesystem.fancyscene.FancyZoom.java-readNextObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(extInterface==null){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2437/pattern-ver1-serial/app.src.main.java.org.gdg.frisbee.android.onboarding.FirstStartStep1Fragment.java-addChapters.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(t==null){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2437/pattern-ver1-serial/app.src.main.java.org.gdg.frisbee.android.onboarding.FirstStartStep1Fragment.java-addChapters.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(extInterface.getConstructor()==null){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2437/pattern-ver1-serial/app.src.main.java.org.gdg.frisbee.android.onboarding.FirstStartStep1Fragment.java-addChapters.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(compiler==null){
+return ;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2437/pattern-ver1-serial/app.src.main.java.org.gdg.frisbee.android.onboarding.FirstStartStep1Fragment.java-addChapters.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
-FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
+ final FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ final FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3285/pattern-ver1-serial/project.core.src.se.computerscience.kelde.model.entities.EntityBat.java-getHeading.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ final ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+ final ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3285/pattern-ver1-serial/project.core.src.se.computerscience.kelde.model.entities.EntityBat.java-getHeading.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ final ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ final FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3285/pattern-ver1-serial/project.core.src.se.computerscience.kelde.model.entities.EntityBat.java-getHeading.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ final FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ final ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3285/pattern-ver1-serial/project.core.src.se.computerscience.kelde.model.entities.EntityBat.java-getHeading.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ final FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+ final ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3285/pattern-ver1-serial/project.core.src.se.computerscience.kelde.model.entities.EntityBat.java-getHeading.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ @SuppressWarnings("UnusedAssignment") ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ @SuppressWarnings("UnusedAssignment") FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ @SuppressWarnings("UnusedAssignment") FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
+ @SuppressWarnings("UnusedAssignment") ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
+ @SuppressWarnings("UnusedAssignment") boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+ @SuppressWarnings("UnusedAssignment") ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
+ @SuppressWarnings("UnusedAssignment") boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ @SuppressWarnings("UnusedAssignment") FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ @SuppressWarnings("UnusedAssignment") FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
+ @SuppressWarnings("UnusedAssignment") boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
-FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
+ @SuppressWarnings("UnusedAssignment") FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ @SuppressWarnings("UnusedAssignment") HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+interfaceType=interfaceType;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(functionType.getExtendedInterfaces()!=null){
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1943/pattern-ver1-serial/app.src.main.java.br.com.battista.myoffers.controller.OfferController.java-saveOfferInDatabase.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
+if(functionType.getExtendedInterfaces()!=null){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1943/pattern-ver1-serial/app.src.main.java.br.com.battista.myoffers.controller.OfferController.java-saveOfferInDatabase.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
+if(functionType.getImplementedInterfaces()!=null){
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+}
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1943/pattern-ver1-serial/app.src.main.java.br.com.battista.myoffers.controller.OfferController.java-saveOfferInDatabase.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+properties=properties;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+t=t;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+n=n;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
-for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
+ final FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ final FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V18/5586/pattern-ver1-serial/querqy-core.src.main.java.querqy.CompoundCharSequence.java-subSequence.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties.equals("")){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/6228/pattern-ver1-serial/src.engine.QueryEngine.java-slice.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(currentProperties.equals("")){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/6228/pattern-ver1-serial/src.engine.QueryEngine.java-slice.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
+if(baseConstructor.equals("")){
+return ;
+}
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/6228/pattern-ver1-serial/src.engine.QueryEngine.java-slice.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+properties.remove(null);
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/4839/pattern-ver1-serial/runtime.src.main.java.com.flipkart.flux.resource.StateMachineResource.java-getGraphData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+currentProperties.remove(null);
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/4839/pattern-ver1-serial/runtime.src.main.java.com.flipkart.flux.resource.StateMachineResource.java-getGraphData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+properties.remove(0);
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V10/3880/pattern-ver1-serial/app.src.main.java.com.aiqing.niuniuheardsensor.activities.HSMainActivity.java-onNewIntent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+properties.remove(0);
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V10/3880/pattern-ver1-serial/app.src.main.java.com.aiqing.niuniuheardsensor.activities.HSMainActivity.java-onNewIntent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
+if(true){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
-if(functionType.isConstructor()){
+if(functionType.isConstructor()==false){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
+if(functionType.isInterface()==false){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(functionType!=null){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/258/pattern-ver1-serial/web.src.main.java.com.epam.freelancer.web.controller.UserController.java-addIsComplaintInOrderings.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties.equals("-1")){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(currentProperties.equals("-1")){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
+if(baseConstructor.equals("-1")){
+return ;
+}
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
+if(proto.equals("-1")){
+return ;
+}
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+ final ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+ final FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+ final HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V37/6206/pattern-ver1-serial/ColFusionServerBLL.src.main.java.edu.pitt.sis.exp.colfusion.bll.BasicTableBL.java-getAttachmentList.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+int a=0;
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+int a=0;
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+int a=0;
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+int a=0;
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
+int a=0;
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
+int a=0;
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
+int a=0;
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
+int a=0;
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
+int a=0;
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
+int a=0;
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties.equals(n)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n.equals(properties)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties.equals(t)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(t.equals(properties)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType.equals(properties)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties.equals(interfaceType)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n.equals(t)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(t.equals(n)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType.equals(n)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n.equals(interfaceType)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5852/pattern-ver1-serial/ganttproject.src.net.sourceforge.ganttproject.TaskContainmentHierarchyFacadeImpl.java-areUnrelated.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+currentProperties.clear();
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V18/6417/pattern-ver1-serial/Code.DoubleAuctionWithNetworks.src.doubleAuction.Auction.java-executeSingleTransaction.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+String OUTSTRING="";
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
+String OUTSTRING="";
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+String OUTSTRING="";
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+String OUTSTRING="";
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
+String OUTSTRING="";
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
+String OUTSTRING="";
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
+String OUTSTRING="";
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+String OUTSTRING="";
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
+String OUTSTRING="";
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
+String OUTSTRING="";
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
+currentProperties.clear();
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/3854/pattern-ver1-serial/NewIntro4.java-act.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
+try{
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}finally{
+currentProperties.clear();
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 1, INS : 0, DEL : 2
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+try{
 properties.putAll(currentProperties);
+}finally{
+currentProperties.clear();
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 1, INS : 0, DEL : 2
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
-if(badImplementedType){
+if(badImplementedType||badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.Reader;
+
+import java.io.InputStream;
+
+import java.io.InputStreamReader;
+
+import java.io.OutputStreamWriter;
+
+import java.io.IOException;
+
+import java.io.OutputStream;
+
+import java.io.Writer;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties.equals(InputStream.class)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1916/pattern-ver1-serial/ambari-server.src.main.java.org.apache.ambari.server.api.GsonJsonProvider.java-readFrom.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.Reader;
+
+import java.io.InputStream;
+
+import java.io.InputStreamReader;
+
+import java.io.OutputStreamWriter;
+
+import java.io.IOException;
+
+import java.io.OutputStream;
+
+import java.io.Writer;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
+if(properties.equals(InputStream.class)){
+return ;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1916/pattern-ver1-serial/ambari-server.src.main.java.org.apache.ambari.server.api.GsonJsonProvider.java-readFrom.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.Reader;
+
+import java.io.InputStream;
+
+import java.io.InputStreamReader;
+
+import java.io.OutputStreamWriter;
+
+import java.io.IOException;
+
+import java.io.OutputStream;
+
+import java.io.Writer;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n.equals(InputStream.class)){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1916/pattern-ver1-serial/ambari-server.src.main.java.org.apache.ambari.server.api.GsonJsonProvider.java-readFrom.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
-if(functionType.isConstructor()){
+if(functionType.isConstructor()==true){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
+if(functionType.isInterface()==true){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+int indexSelection=0;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
+int indexSelection=0;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+int indexSelection=0;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+int indexSelection=0;
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
+int indexSelection=0;
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
+int indexSelection=0;
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+int indexSelection=0;
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
+int indexSelection=0;
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
+int indexSelection=0;
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
+int indexSelection=0;
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(n.equals("setPackMode")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/2611/pattern-ver1-serial/app.src.main.java.com.example.kristian.ideacreator.IdeasContentProvider.java-call.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(properties.equals("setPackMode")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/2611/pattern-ver1-serial/app.src.main.java.com.example.kristian.ideacreator.IdeasContentProvider.java-call.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(t.equals("setPackMode")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/2611/pattern-ver1-serial/app.src.main.java.com.example.kristian.ideacreator.IdeasContentProvider.java-call.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(currentProperties.equals("setPackMode")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/2611/pattern-ver1-serial/app.src.main.java.com.example.kristian.ideacreator.IdeasContentProvider.java-call.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(functionPrivateName.equals("setPackMode")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/2611/pattern-ver1-serial/app.src.main.java.com.example.kristian.ideacreator.IdeasContentProvider.java-call.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(properties.equals("sounds")){
+continue;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties.equals("sounds")){
+continue;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(n.equals("sounds")){
+continue;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(t.equals("sounds")){
+continue;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(interfaceType.equals("sounds")){
+continue;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties.equals("sounds")){
+continue;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(currentProperties.equals("sounds")){
+continue;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(extInterface.equals("sounds")){
+continue;
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(baseConstructor.equals(getNativeType(OBJECT_FUNCTION_TYPE))){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/343/pattern-ver1-serial/src.gui.batches.ItemBatchView.java-selectProduct.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(getNativeType(OBJECT_FUNCTION_TYPE).equals(baseConstructor)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7020/pattern-ver1-serial/simulator.src.main.java.com.hazelcast.simulator.protocol.connector.AbstractServerConnector.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(properties.size()<=0){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V18/5648/pattern-ver1-serial/applications.plugins.org.csstudio.opibuilder.src.org.csstudio.opibuilder.pvmanager.PVManagerHelper.java-formatNumberArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties.size()<=0){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V18/5648/pattern-ver1-serial/applications.plugins.org.csstudio.opibuilder.src.org.csstudio.opibuilder.pvmanager.PVManagerHelper.java-formatNumberArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties.size()<=0){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V18/5648/pattern-ver1-serial/applications.plugins.org.csstudio.opibuilder.src.org.csstudio.opibuilder.pvmanager.PVManagerHelper.java-formatNumberArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(currentProperties.size()<=0){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V18/5648/pattern-ver1-serial/applications.plugins.org.csstudio.opibuilder.src.org.csstudio.opibuilder.pvmanager.PVManagerHelper.java-formatNumberArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties.size()<=0){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V18/5648/pattern-ver1-serial/applications.plugins.org.csstudio.opibuilder.src.org.csstudio.opibuilder.pvmanager.PVManagerHelper.java-formatNumberArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+properties.putAll(currentProperties);
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(0>=properties.size()){
+return ;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V7/5077/pattern-ver1-serial/src.Utils.Helper.java-getModeInt.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(0>=currentProperties.size()){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V7/5077/pattern-ver1-serial/src.Utils.Helper.java-getModeInt.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(0>=currentProperties.size()){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V7/5077/pattern-ver1-serial/src.Utils.Helper.java-getModeInt.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(0>=currentProperties.size()){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V7/5077/pattern-ver1-serial/src.Utils.Helper.java-getModeInt.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(0>=properties.size()){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V7/5077/pattern-ver1-serial/src.Utils.Helper.java-getModeInt.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+properties.putAll(currentProperties);
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+properties.putAll(currentProperties);
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties.size()>0){
 currentProperties.clear();
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/506/pattern-ver1-serial/app.src.main.java.com.jessie.guessnumber.MainActivity.java-delete.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties.size()>0){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/506/pattern-ver1-serial/app.src.main.java.com.jessie.guessnumber.MainActivity.java-delete.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
+badImplementedType=true;
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+badImplementedType=true;
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+badImplementedType=true;
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+badImplementedType=true;
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(true){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(true){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1==false){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)==false){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties.size()>0){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/2897/pattern-ver1-serial/src.main.java.org.restonfire.FirebaseRestQueryImpl.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1||functionType.getExtendedInterfacesCount()==Long.MIN_VALUE){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+properties.put("collectionId",interfaceType);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2343/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.home.library.LibraryTopicListView.java-oncustomizeCollectionBtnClicked.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V32/4434/pattern-ver1-serial/gui.src.main.java.org.jboss.as.console.client.shared.subsys.messaging.forms.ConnectorForm.java-asWidget.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
+if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V48/2335/pattern-ver1-serial/app.src.main.java.swampthings.dems.LoginActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
+badImplementedType=true;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V48/2335/pattern-ver1-serial/app.src.main.java.swampthings.dems.LoginActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+try{
 currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}finally{
 properties.putAll(currentProperties);
+}
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 1, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+try{
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}finally{
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 1, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+assert (properties!=null);
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+assert (properties!=null);
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+assert (n!=null);
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+assert (!properties.isEmpty());
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+assert (!properties.isEmpty());
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+assert (!n.isEmpty());
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+assert (!n.isEmpty());
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+assert (!n.isEmpty());
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(Double.isNaN(functionType.getExtendedInterfacesCount())){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1==true){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties!=null){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType!=null){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+assert (properties!=new HashMap<String,ObjectType>());
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+assert (currentProperties!=new HashMap<String,ObjectType>());
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
+assert (baseConstructor!=functionType.getSuperClassConstructor());
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if((extInterface.getConstructor()!=null)&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/4601/pattern-ver1-serial/core.src.by.matveev.rorty.entities.Robot.java-updateControlState.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if((baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE))&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/4601/pattern-ver1-serial/core.src.by.matveev.rorty.entities.Robot.java-updateControlState.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+assert (functionPrivateName!=null);
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+assert (functionPrivateName!=null);
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+assert (functionPrivateName!=null);
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
+assert (functionPrivateName!=null);
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
+assert (functionPrivateName!=null);
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/1113/pattern-ver1-serial/src.main.java.org.encog.neural.neat.training.NEATTraining.java-crossover.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/1113/pattern-ver1-serial/src.main.java.org.encog.neural.neat.training.NEATTraining.java-crossover.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.io.IOException;
+
+import java.io.InputStream;
+
+import java.io.FileOutputStream;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n.toString().startsWith("content://com.ianhanniballake.localstorage")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7703/pattern-ver1-serial/android.src.main.java.org.openforis.collect.android.gui.SurveyListActivity.java-getFileNameByUri.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
+if(baseInterfaceObj!=null||"".equals(baseInterfaceObj)){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)||"".equals(baseConstructor)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1||"".equals(functionType.getExtendedInterfacesCount())){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1||functionType.getExtendedInterfacesCount()==3){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface!=null&&extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/1720/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.block.XIVMaskingOrchestrator.java-exportGroupAddVolumes.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
-if(functionType.isConstructor()){
+if(functionType!=null&&functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5865/pattern-ver1-serial/gde-webapp.src.main.java.com.nagarro.gde.validator.UserInternaturValidator.java-validateRequiredData.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
+if(functionType!=null&&functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5865/pattern-ver1-serial/gde-webapp.src.main.java.com.nagarro.gde.validator.UserInternaturValidator.java-validateRequiredData.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType!=null&&functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V15/6389/pattern-ver1-serial/src.org.ohmage.conditionevaluator.comparator.SingleChoiceDataPointComparator.java-lessThan.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties.isEmpty()){
+properties=null;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(properties.isEmpty()){
+properties=null;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(n.isEmpty()){
+n=null;
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()<0||functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+properties.remove(properties.get(0));
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/5778/pattern-ver1-serial/src.LinkedList.java-main.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+currentProperties.remove(currentProperties.get(0));
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/5778/pattern-ver1-serial/src.LinkedList.java-main.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
+if(currentProperties!=null){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V62/5851/pattern-ver1-serial/src.main.java.com.dynious.refinedrelocation.grid.GridMemberHandler.java-onTileRemoved.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 3, INS : 0, DEL : 2
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
-if(functionType.isConstructor()){
+if((functionType!=null)&&(functionType.isConstructor())){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/4845/pattern-ver1-serial/app.src.main.java.hu.bme.aut.szabolcs.szokol.countryinfo.ui.main.MainActivity.java-onBackPressed.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
+if((functionType!=null)&&(functionType.isInterface())){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/4845/pattern-ver1-serial/app.src.main.java.hu.bme.aut.szabolcs.szokol.countryinfo.ui.main.MainActivity.java-onBackPressed.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1||functionType.getExtendedInterfacesCount()==0){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+if(properties.getClass().getSimpleName().startsWith("SystemException")){
+return ;
+}
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties.getClass().getSimpleName().startsWith("SystemException")){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(n.getClass().getSimpleName().startsWith("SystemException")){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(t.getClass().getSimpleName().startsWith("SystemException")){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(interfaceType.getClass().getSimpleName().startsWith("SystemException")){
+return ;
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+if(n.getClass().getSimpleName().startsWith("SystemException")){
+return ;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/3872/pattern-ver1-serial/sdk.src.main.java.com.amazon.speech.speechlet.verifier.ApplicationIdSpeechletRequestVerifier.java-verify.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1||functionType.getExtendedInterfacesCount()>9){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la cancin","Error",JOptionPane.ERROR_MESSAGE);
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1&&functionType.getExtendedInterfacesCount()<4000000){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)||baseConstructor==null){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/4704/pattern-ver1-serial/src.main.java.com.alibaba.fastjson.parser.ParserConfig.java-createJavaBeanDeserializer.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
+if(baseInterfaceObj!=null||baseInterfaceObj==null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/4704/pattern-ver1-serial/src.main.java.com.alibaba.fastjson.parser.ParserConfig.java-createJavaBeanDeserializer.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
-FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
+FunctionType functionType=JSType.toMaybeFunctionType(n==null?null:n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/4299/pattern-ver1-serial/client.synapseJavaClient.src.main.java.org.sagebionetworks.client.SynapseClientImpl.java-uploadToS3FileHandle.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(functionType.getExtendedInterfacesCount()>1&&functionType.getExtendedInterfacesCount()!=9999){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
-if(functionType.getExtendedInterfacesCount()>1){
+if(1>0&&functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if((functionType!=null&&functionType.makesStructs())&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2151/pattern-ver1-serial/coeus-impl.src.main.java.org.kuali.kra.award.document.authorization.AwardDocumentAuthorizer.java-canCancel.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if((functionType!=null&&functionType.makesDicts())&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2151/pattern-ver1-serial/coeus-impl.src.main.java.org.kuali.kra.award.document.authorization.AwardDocumentAuthorizer.java-canCancel.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
-if(functionType.isConstructor()){
+if(functionType==null||functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V23/443/pattern-ver1-serial/bundles.opaeum-compilation.org.opaeum.compilation.java.src.org.opaeum.javageneration.bpm.actions.AbstractProtectedNodeBuilder.java-implementCallbackOnComplete.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
+if(functionType==null||functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V23/443/pattern-ver1-serial/bundles.opaeum-compilation.org.opaeum.compilation.java.src.org.opaeum.javageneration.bpm.actions.AbstractProtectedNodeBuilder.java-implementCallbackOnComplete.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
-FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
+FunctionType functionType=JSType.toMaybeFunctionType(n!=null?n.getJSType():null);
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/4302/pattern-ver1-serial/src.com.floreantpos.model.KitchenTicket.java-fromTicket.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
+ObjectType proto=functionType.getPrototype();
 }

PATTERN : /home/jiajun/GithubData/2011/V5/1113/pattern-ver1-serial/src.main.java.org.encog.neural.neat.training.NEATTraining.java-crossover.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+JOptionPane.showMessageDialog(null,"Uspjeno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(functionType.makesDicts()&&!proto.isDict()||"".equals(functionType.makesDicts())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if(functionType.makesStructs()&&!proto.isStruct()||"".equals(functionType.makesStructs())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if(!functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V53/1790/pattern-ver1-serial/src.main.java.syam.Honeychest.config.ConfigurationManager.java-checkver.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(!functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V53/1790/pattern-ver1-serial/src.main.java.syam.Honeychest.config.ConfigurationManager.java-checkver.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(extInterface==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(t==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(compiler==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(extInterface.getConstructor()==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties==null){
+throw new IllegalStateException("Cannot instantiate Page whitout String url constructor parameter or @PageURL class annotation");
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4732/pattern-ver1-serial/src.main.java.com.mgiorda.page.AbstractPage.java-AbstractPage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if(functionType!=null&&functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V15/6389/pattern-ver1-serial/src.org.ohmage.conditionevaluator.comparator.SingleChoiceDataPointComparator.java-lessThan.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(functionType!=null&&functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V15/6389/pattern-ver1-serial/src.org.ohmage.conditionevaluator.comparator.SingleChoiceDataPointComparator.java-lessThan.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+validator.expectAllInterfaceProperties(t,n,functionType);
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/2451/pattern-ver1-serial/ShopNow.src.shopnow.Customer_Account.java-get_phone_number.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(currentProperties!=null){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/7166/pattern-ver1-serial/src.main.java.net.dandielo.core.items.dItem.java-addAttribute.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+validator.expectAllInterfaceProperties(t,n,functionType);
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if(true){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(true){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(functionType.makesDicts()&&!proto.isDict()==false){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(properties!=null){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V62/5851/pattern-ver1-serial/src.main.java.com.dynious.refinedrelocation.grid.GridMemberHandler.java-onTileRemoved.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+validator.expectAllInterfaceProperties(t,n,functionType);
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
+validator.expectAllInterfaceProperties(t,n,functionType);
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
+validator.expectAllInterfaceProperties(t,n,functionType);
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
+validator.expectAllInterfaceProperties(t,n,functionType);
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+validator.expectAllInterfaceProperties(t,n,functionType);
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
+validator.expectAllInterfaceProperties(t,n,functionType);
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
+validator.expectAllInterfaceProperties(t,n,functionType);
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+validator.expectAllInterfaceProperties(t,n,functionType);
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
+validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+validator.expectAllInterfaceProperties(t,n,functionType);
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties!=null){
 currentProperties.clear();
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/7443/pattern-ver1-serial/app.src.main.java.com.example.mobile.smartcycledemo.bluetooth.BluetoothLeService.java-setCharacteristicNotification.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/6314/pattern-ver1-serial/app.src.main.java.mobile.tiis.app.postman.SynchronisationService.java-onHandleIntent.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/6314/pattern-ver1-serial/app.src.main.java.mobile.tiis.app.postman.SynchronisationService.java-onHandleIntent.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/6314/pattern-ver1-serial/app.src.main.java.mobile.tiis.app.postman.SynchronisationService.java-onHandleIntent.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType==null){
+return ;
+}
+if(properties==null){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType==null){
+return ;
+}
+if(n==null){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType==null){
+return ;
+}
+if(t==null){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V4/5645/pattern-ver1-serial/model.src.main.java.uk.ac.ebi.bioinvindex.utils.datasourceload.DataLocationManager.java-buildLocationFromRawParam.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if(!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/3688/pattern-ver1-serial/src.main.java.erogenousbeef.bigreactors.common.multiblock.MultiblockReactor.java-changeAllControlRodInsertionValues.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/3688/pattern-ver1-serial/src.main.java.erogenousbeef.bigreactors.common.multiblock.MultiblockReactor.java-changeAllControlRodInsertionValues.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if(functionType.makesStructs()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/1184/pattern-ver1-serial/swagplash.src.main.java.com.github.albertosh.swagplash.actions.ApiBodyParamAction.java-call.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(functionType.makesDicts()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/1184/pattern-ver1-serial/swagplash.src.main.java.com.github.albertosh.swagplash.actions.ApiBodyParamAction.java-call.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if(functionType.makesStructs()&&!proto.isStruct()==true){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(functionType.makesDicts()&&!proto.isDict()==true){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+compiler.report(t==null?null:t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/4299/pattern-ver1-serial/client.synapseJavaClient.src.main.java.org.sagebionetworks.client.SynapseClientImpl.java-uploadToS3FileHandle.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+compiler.report(t==null?null:t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/4299/pattern-ver1-serial/client.synapseJavaClient.src.main.java.org.sagebionetworks.client.SynapseClientImpl.java-uploadToS3FileHandle.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+compiler.report(t==null?null:t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/4299/pattern-ver1-serial/client.synapseJavaClient.src.main.java.org.sagebionetworks.client.SynapseClientImpl.java-uploadToS3FileHandle.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+compiler.report(t==null?null:t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V31/4299/pattern-ver1-serial/client.synapseJavaClient.src.main.java.org.sagebionetworks.client.SynapseClientImpl.java-uploadToS3FileHandle.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties!=null){
 currentProperties.clear();
+}
+if(currentProperties!=null){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4107/pattern-ver1-serial/src.baseline.hvac.system7.HVACSystem7.java-checkSupplySideSystem.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(properties!=null){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}
+if(properties!=null){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/4107/pattern-ver1-serial/src.baseline.hvac.system7.HVACSystem7.java-checkSupplySideSystem.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+compiler.report(t!=null?t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName):null);
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/4302/pattern-ver1-serial/src.com.floreantpos.model.KitchenTicket.java-fromTicket.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+compiler.report(t!=null?t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName):null);
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/4302/pattern-ver1-serial/src.com.floreantpos.model.KitchenTicket.java-fromTicket.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+compiler.report(t!=null?t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName):null);
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/4302/pattern-ver1-serial/src.com.floreantpos.model.KitchenTicket.java-fromTicket.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+compiler.report(t!=null?t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName):null);
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/4302/pattern-ver1-serial/src.com.floreantpos.model.KitchenTicket.java-fromTicket.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties.equals("CALL_RECEIVED_AT")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(properties.equals("NAME")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(n.equals("CALL_RECEIVED_AT")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(n.equals("NAME")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(t.equals("CALL_RECEIVED_AT")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(t.equals("NAME")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(interfaceType.equals("CALL_RECEIVED_AT")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(interfaceType.equals("NAME")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
+if(n.equals("CALL_RECEIVED_AT")){
+return ;
+}
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
+if(n.equals("NAME")){
+return ;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(functionPrivateName.equals("CALL_RECEIVED_AT")){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+if(functionPrivateName.equals("NAME")){
+return ;
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/4139/pattern-ver1-serial/cadpage.src.net.anei.cadpage.parsers.IL.ILMadisonCountyParser.java-getField.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()||"".equals(interfaceConstructor!=null)){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if(interfaceConstructor!=null){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V4/6809/pattern-ver1-serial/app.src.main.java.org.votingsystem.service.WebSocketService.java-sendWebSocketBroadcast.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()==false){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(currentProperties==null||properties==null){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/6302/pattern-ver1-serial/modules.core.src.main.java.io.smsc.repository.customer.customer.CustomerRepositoryImpl.java-removeUser.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 7, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+if(properties==null||currentProperties==null){
+return ;
+}
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/6302/pattern-ver1-serial/modules.core.src.main.java.io.smsc.repository.customer.customer.CustomerRepositoryImpl.java-removeUser.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 7, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if(badImplementedType&&(interfaceConstructor!=null&&!interfaceConstructor.isInterface())){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if(!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/3688/pattern-ver1-serial/src.main.java.erogenousbeef.bigreactors.common.multiblock.MultiblockReactor.java-changeAllControlRodInsertionValues.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor.equals(getNativeType(OBJECT_FUNCTION_TYPE))&&baseConstructor.equals(null)&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/3979/pattern-ver1-serial/PrimaryHelper.java-run.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+if(baseInterfaceObj==null){
+throw new IllegalStateException("User isn't registered! "+baseInterface);
+}
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
+if(proto==null){
+throw new IllegalStateException("User isn't registered! "+functionType);
+}
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
+if(baseConstructor==null){
+throw new IllegalStateException("User isn't registered! "+functionType);
+}
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/6358/pattern-ver1-serial/src.main.java.com.builtbroken.icbm.content.ams.TileAMSClient.java-onPlayerRightClick.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+synchronized(this){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
+synchronized(this){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
+synchronized(this){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+}
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+synchronized(this){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+}
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
+if(properties==null){
+System.out.println("UNKOWN PLAYER TRIED UNLOCK BUG WITHOUT REGISTATION: "+functionType.getDisplayName());
+return ;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V11/3018/pattern-ver1-serial/src.main.java.hok.chompzki.biocristals.items.insects.ItemUnlockBug.java-onEaten.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+try{
 currentProperties.clear();
+}finally{
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 1, INS : 0, DEL : 7
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+try{
 properties.putAll(currentProperties);
+}finally{
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 1, INS : 0, DEL : 7
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
+if(properties!=null){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/1112/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.xtremio.XtremIOSnapshotOperations.java-createGroupSnapshots.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 3, INS : 0, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
+if(currentProperties!=null){
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/1112/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.xtremio.XtremIOSnapshotOperations.java-createGroupSnapshots.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 3, INS : 0, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if((baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null)&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/4601/pattern-ver1-serial/core.src.by.matveev.rorty.entities.Robot.java-updateControlState.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()||"".equals(extInterface.getConstructor()!=null)){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface.getConstructor()!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V1/6020/pattern-ver1-serial/src.main.java.org.basex.data.MapTree.java-deletePreTree.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(true){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()==false){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/156/pattern-ver1-serial/ControlCenter.src.main.java.org.votingsystem.web.controlcenter.filter.FilterVS.java-doFilter.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()==true){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(properties==null||interfaceType==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(n==null||interfaceType==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
+if(t==null||interfaceType==null){
+throw new NullPointerException();
+}
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties!=null){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/7166/pattern-ver1-serial/src.main.java.net.dandielo.core.items.dItem.java-addAttribute.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 3, INS : 0, DEL : 7
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties!=null){
 currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V62/5851/pattern-ver1-serial/src.main.java.com.dynious.refinedrelocation.grid.GridMemberHandler.java-onTileRemoved.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 3, INS : 0, DEL : 7
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(properties!=null){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V62/5851/pattern-ver1-serial/src.main.java.com.dynious.refinedrelocation.grid.GridMemberHandler.java-onTileRemoved.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 3, INS : 0, DEL : 7
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()||"".equals(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null)){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties==null||interfaceType==null||n==null){
+return ;
+}
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/1014/pattern-ver1-serial/src.main.java.HxCKDMS.HxCEnchants.Handlers.EnchantHandlers.java-handleBootEnchant.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(true){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()==false){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if((functionType.makesStructs())&&(!proto.isStruct())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if((interfaceConstructor!=null)&&(!interfaceConstructor.isInterface())){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if((functionType.makesDicts())&&(!proto.isDict())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if((interfaceConstructor!=null)&&(!interfaceConstructor.isInterface())){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties!=null){
+if(currentProperties!=null){
 currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+}
 properties.putAll(currentProperties);
+}
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/7882/pattern-ver1-serial/RaspiMediaCenter.src.raspimediacenter.Logic.Utilities.ScraperUtils.java-scraperParseAlbum.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 8, INS : 0, DEL : 3
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()==true){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+if(currentProperties!=null){
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/1112/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.xtremio.XtremIOSnapshotOperations.java-createGroupSnapshots.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 3, INS : 0, DEL : 9
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/3709/pattern-ver1-serial/src.main.java.jfxtras.labs.scene.layout.GridPane.java-apply.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
+if((functionType.makesStructs())&&(!proto.isStruct())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if((extInterface.getConstructor()!=null)&&(!extInterface.getConstructor().isInterface())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if((functionType.makesDicts())&&(!proto.isDict())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if((extInterface.getConstructor()!=null)&&(!extInterface.getConstructor().isInterface())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
-validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/5667/pattern-ver1-serial/src.AccessorBean.java-onPageLoaded.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 8, INS : 0, DEL : 5
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+ObjectType proto=functionType.getPrototype();
+if(functionType.makesStructs()&&!proto.isStruct()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+}else {
+if(functionType.makesDicts()&&!proto.isDict()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
+}
+}
+for(JSType baseInterface : functionType.getImplementedInterfaces()){
+boolean badImplementedType=false;
+ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
+if(baseInterfaceObj!=null){
+FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+badImplementedType=true;
+}
+}else {
+badImplementedType=true;
+}
+if(badImplementedType){
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+}
+}
+validator.expectAllInterfaceProperties(t,n,functionType);
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3134/pattern-ver1-serial/app.src.main.java.ru.vif2ne.ui.MainActivity.java-refreshBottomMenu.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(currentProperties!=null){
 currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/1112/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.xtremio.XtremIOSnapshotOperations.java-createGroupSnapshots.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 3, INS : 0, DEL : 10
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+if(properties!=null){
 currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/1112/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.xtremio.XtremIOSnapshotOperations.java-createGroupSnapshots.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 3, INS : 0, DEL : 10
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+long startTime=System.currentTimeMillis();
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+long startTime=System.currentTimeMillis();
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+long startTime=System.currentTimeMillis();
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
+long startTime=System.currentTimeMillis();
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
+long startTime=System.currentTimeMillis();
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+long startTime=System.currentTimeMillis();
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
+long startTime=System.currentTimeMillis();
 badImplementedType=true;
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+long startTime=System.currentTimeMillis();
 badImplementedType=true;
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
+long startTime=System.currentTimeMillis();
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
+long startTime=System.currentTimeMillis();
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
+synchronized(this){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
+}
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 14, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if((interfaceConstructor!=null)&&(!interfaceConstructor.isInterface())){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+if((extInterface.getConstructor()!=null)&&(!extInterface.getConstructor().isInterface())){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 14, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
+}else {
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 14, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
-}
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2729/pattern-ver1-serial/Spykes.CloudVision.app.src.main.java.inovation.lab.cloudvision.Speech.java-onInit.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 14, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
+if(baseInterfaceObj!=null&&baseConstructor.isInterface()){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V21/4076/pattern-ver1-serial/moho-impl.src.main.java.com.voxeo.moho.sip.DirectAI2NOJoinDelegate.java-doInviteResponse.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 14, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
-if(badImplementedType){
+if(badImplementedType&&baseConstructor.isInterface()){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V21/4076/pattern-ver1-serial/moho-impl.src.main.java.com.voxeo.moho.sip.DirectAI2NOJoinDelegate.java-doInviteResponse.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 14, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
+if(functionType.makesDicts()&&!proto.isDict()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 15, UPD : 0, INS : 1, DEL : 14
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor.isInterface()){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V21/4076/pattern-ver1-serial/moho-impl.src.main.java.com.voxeo.moho.sip.DirectAI2NOJoinDelegate.java-doInviteResponse.pattern
MATCHLEVEL : ALL
ALL : 15, UPD : 15, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+if(functionType.makesDicts()&&!proto.isDict()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3134/pattern-ver1-serial/app.src.main.java.ru.vif2ne.ui.MainActivity.java-refreshBottomMenu.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 16, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
+}else {
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2567/pattern-ver1-serial/bridge-impl.src.main.java.com.liferay.faces.bridge.internal.BridgePhaseBaseImpl.java-initBridgeRequestScope.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
+if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
+if(functionType.makesDicts()&&!proto.isDict()&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V21/4076/pattern-ver1-serial/moho-impl.src.main.java.com.voxeo.moho.sip.DirectAI2NOJoinDelegate.java-doInviteResponse.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
+if(functionPrivateName.substring(11,19).equals("00:00:00")){
+functionPrivateName=functionPrivateName.substring(0,11)+"23:59:59"+functionPrivateName.substring(19);
+}
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/2005/pattern-ver1-serial/dspace-oai.src.main.java.org.dspace.xoai.filter.DateUntilFilter.java-buildSolrQuery.pattern
MATCHLEVEL : ALL
ALL : 18, UPD : 0, INS : 18, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+if(baseInterfaceObj==null){
 badImplementedType=true;
-}
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/7842/pattern-ver1-serial/plugins.org.csstudio.saverestore.ui.src.org.csstudio.saverestore.ui.util.RepositoryTree.java-getValueFromComponent.pattern
MATCHLEVEL : ALL
ALL : 18, UPD : 18, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
+if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
+badImplementedType=true;
+}
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/3709/pattern-ver1-serial/src.main.java.jfxtras.labs.scene.layout.GridPane.java-apply.pattern
MATCHLEVEL : ALL
ALL : 19, UPD : 19, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
+synchronized(this){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 22, UPD : 22, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
+if(functionType.getExtendedInterfacesCount()==12){
+return ;
+}else {
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V39/4902/pattern-ver1-serial/app.src.main.java.com.cs180project.ucrclasses.BaseCalendarActivity.java-interpretTime.pattern
MATCHLEVEL : ALL
ALL : 26, UPD : 26, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+}
+if(functionType.getExtendedInterfacesCount()>1){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
+}
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
-for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
-}
+report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/3709/pattern-ver1-serial/src.main.java.jfxtras.labs.scene.layout.GridPane.java-apply.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 27, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
-}
-}
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/926/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.FileVirtualPoolService.java-prepareVirtualPool.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
+}
 }
 }
+if(functionType.getExtendedInterfacesCount()>1){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/926/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.FileVirtualPoolService.java-prepareVirtualPool.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
-}
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/926/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.FileVirtualPoolService.java-prepareVirtualPool.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
+if(functionType.getExtendedInterfacesCount()>1){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
+}
+}
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
-}
-}
-if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
-for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/926/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.FileVirtualPoolService.java-prepareVirtualPool.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
+if(functionType.getExtendedInterfacesCount()>1){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
+}
+}
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/926/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.FileVirtualPoolService.java-prepareVirtualPool.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}
+if(functionType.getExtendedInterfacesCount()>1){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+if(functionType.getExtendedInterfacesCount()>1){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
+}
+}
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 28, UPD : 0, INS : 0, DEL : 28
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
+if(functionType.makesStructs()&&!proto.isStruct()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
+}else {
+if(functionType.makesDicts()&&!proto.isDict()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
+synchronized(this){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
+}
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 32, UPD : 32, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
+}else {
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 32, UPD : 32, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/6802/pattern-ver1-serial/FtcRobotController.src.main.java.com.qualcomm.ftcrobotcontroller.opmodes.PacmanBotHardwareBase.java-checkUsers.pattern
MATCHLEVEL : ALL
ALL : 32, UPD : 32, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/6802/pattern-ver1-serial/FtcRobotController.src.main.java.com.qualcomm.ftcrobotcontroller.opmodes.PacmanBotHardwareBase.java-checkUsers.pattern
MATCHLEVEL : ALL
ALL : 32, UPD : 32, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
+synchronized(this){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 47, UPD : 47, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
+}else {
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V2/2933/pattern-ver1-serial/common.common-io.src.main.java.com.twelvemonkeys.io.AbstractCachedSeekableStream.java-seekImpl.pattern
MATCHLEVEL : ALL
ALL : 47, UPD : 47, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
-for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
-}
-}
-if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
-}
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3131/pattern-ver1-serial/src.cofh.tweak.asmhooks.render.RenderGlobal.java-markRenderers.pattern
MATCHLEVEL : ALL
ALL : 47, UPD : 47, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
-for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
-}
-}
-if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
-for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
-}
-}
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2729/pattern-ver1-serial/Spykes.CloudVision.app.src.main.java.inovation.lab.cloudvision.Speech.java-onInit.pattern
MATCHLEVEL : ALL
ALL : 47, UPD : 47, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
-for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
-}
-}
-if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
-for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
-}
-}
-}
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 49, UPD : 0, INS : 0, DEL : 49
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
-for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
-}
-}
-if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
-}
-}
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4089/pattern-ver1-serial/Loughborough.src.uk.ac.lboro.android.apps.Loughborough.Other.NormalWebview.java-onBackPressed.pattern
MATCHLEVEL : ALL
ALL : 49, UPD : 49, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
-}
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V2/2933/pattern-ver1-serial/common.common-io.src.main.java.com.twelvemonkeys.io.AbstractCachedSeekableStream.java-seekImpl.pattern
MATCHLEVEL : ALL
ALL : 49, UPD : 49, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
-if(functionType.isInterface()){
-for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
-}
-}
-if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
-for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
-}
-}
-}
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 49, UPD : 49, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
+}else {
+if(functionType==null){
+return ;
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3795/pattern-ver1-serial/opentripplanner-routing.src.main.java.org.opentripplanner.routing.edgetype.PlainStreetEdge.java-calculateSpeed.pattern
MATCHLEVEL : ALL
ALL : 49, UPD : 49, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
+}
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
-}
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/926/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.FileVirtualPoolService.java-prepareVirtualPool.pattern
MATCHLEVEL : ALL
ALL : 50, UPD : 0, INS : 1, DEL : 49
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
-}
-validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V54/1742/pattern-ver1-serial/obdalib-protege41.src.main.java.it.unibz.krdb.obda.protege4.gui.action.R2RMLImportAction.java-actionPerformed.pattern
MATCHLEVEL : ALL
ALL : 79, UPD : 79, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
-if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
-}
-validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V54/1742/pattern-ver1-serial/obdalib-protege41.src.main.java.it.unibz.krdb.obda.protege4.gui.action.R2RMLImportAction.java-actionPerformed.pattern
MATCHLEVEL : ALL
ALL : 79, UPD : 79, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
 }else {
-badImplementedType=true;
-}
-if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
-}
-validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V2/2933/pattern-ver1-serial/common.common-io.src.main.java.com.twelvemonkeys.io.AbstractCachedSeekableStream.java-seekImpl.pattern
MATCHLEVEL : ALL
ALL : 79, UPD : 79, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
-validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/3950/pattern-ver1-serial/predictiveclustering.src.main.java.predictiveclustering.utils.Split.java-splitGroup.pattern
MATCHLEVEL : ALL
ALL : 79, UPD : 79, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
-}
-validator.expectAllInterfaceProperties(t,n,functionType);
-}
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4121/pattern-ver1-serial/main.plugins.org.talend.dataprofiler.core.src.org.talend.dataprofiler.core.ImageLib.java-getImageNameByRepositoryNode.pattern
MATCHLEVEL : ALL
ALL : 98, UPD : 0, INS : 0, DEL : 98
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
+synchronized(this){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
+}
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 102, UPD : 102, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
-}
-validator.expectAllInterfaceProperties(t,n,functionType);
-}
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/3709/pattern-ver1-serial/src.main.java.jfxtras.labs.scene.layout.GridPane.java-apply.pattern
MATCHLEVEL : ALL
ALL : 102, UPD : 102, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
 }
-validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3131/pattern-ver1-serial/src.cofh.tweak.asmhooks.render.RenderGlobal.java-markRenderers.pattern
MATCHLEVEL : ALL
ALL : 102, UPD : 102, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
-}
-validator.expectAllInterfaceProperties(t,n,functionType);
-}
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3131/pattern-ver1-serial/src.cofh.tweak.asmhooks.render.RenderGlobal.java-markRenderers.pattern
MATCHLEVEL : ALL
ALL : 102, UPD : 102, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
-}
-validator.expectAllInterfaceProperties(t,n,functionType);
-}
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V16/3937/pattern-ver1-serial/src.Main.Analysis.java-calculatePrecisionRecall.pattern
MATCHLEVEL : ALL
ALL : 102, UPD : 102, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
+if(functionType.isInterface()){
+for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
-}else {
-badImplementedType=true;
 }
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
+if(functionType.getExtendedInterfacesCount()>1){
+HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
+HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
+for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
+currentProperties.clear();
+checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
+properties.putAll(currentProperties);
 }
 }
-validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3134/pattern-ver1-serial/app.src.main.java.ru.vif2ne.ui.MainActivity.java-refreshBottomMenu.pattern
MATCHLEVEL : ALL
ALL : 110, UPD : 110, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
 if(functionType.isConstructor()){
+compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
+}else {
+if(functionType.isInterface()){
+for(ObjectType extInterface : functionType.getExtendedInterfaces()){
+if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
-}else {
-if(functionType.isInterface()){
-for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V16/3937/pattern-ver1-serial/src.Main.Analysis.java-calculatePrecisionRecall.pattern
MATCHLEVEL : ALL
ALL : 110, UPD : 110, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
+if(functionType==null){
+return ;
+}else {
 if(functionType.isConstructor()){
 FunctionType baseConstructor=functionType.getSuperClassConstructor();
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
 }else {
 if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
 ObjectType proto=functionType.getPrototype();
 if(functionType.makesStructs()&&!proto.isStruct()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
 }else {
 if(functionType.makesDicts()&&!proto.isDict()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
 }
 }
 }
 for(JSType baseInterface : functionType.getImplementedInterfaces()){
 boolean badImplementedType=false;
 ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
 if(baseInterfaceObj!=null){
 FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
 if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
 badImplementedType=true;
 }
 }else {
 badImplementedType=true;
 }
 if(badImplementedType){
 report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
 }
 }
 validator.expectAllInterfaceProperties(t,n,functionType);
 }
 }else {
 if(functionType.isInterface()){
 for(ObjectType extInterface : functionType.getExtendedInterfaces()){
 if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
 compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
 }
 }
 if(functionType.getExtendedInterfacesCount()>1){
 HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
 HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
 for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
 currentProperties.clear();
 checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
 properties.putAll(currentProperties);
+}
 }
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3795/pattern-ver1-serial/opentripplanner-routing.src.main.java.org.opentripplanner.routing.edgetype.PlainStreetEdge.java-calculateSpeed.pattern
MATCHLEVEL : ALL
ALL : 153, UPD : 153, INS : 0, DEL : 0
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/closure/closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java[1594,1670]
------------Candidate---------------
 private void visitFunction(NodeTraversal t,Node n){
 FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
 String functionPrivateName=n.getFirstChild().getString();
-if(functionType.isConstructor()){
-FunctionType baseConstructor=functionType.getSuperClassConstructor();
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)&&baseConstructor!=null&&baseConstructor.isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
-}else {
-if(baseConstructor!=getNativeType(OBJECT_FUNCTION_TYPE)){
-ObjectType proto=functionType.getPrototype();
-if(functionType.makesStructs()&&!proto.isStruct()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
-}else {
-if(functionType.makesDicts()&&!proto.isDict()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
-}
-}
-}
-for(JSType baseInterface : functionType.getImplementedInterfaces()){
-boolean badImplementedType=false;
-ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
-if(baseInterfaceObj!=null){
-FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
-if(interfaceConstructor!=null&&!interfaceConstructor.isInterface()){
-badImplementedType=true;
-}
-}else {
-badImplementedType=true;
-}
-if(badImplementedType){
-report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
-}
-}
-validator.expectAllInterfaceProperties(t,n,functionType);
-}
-}else {
-if(functionType.isInterface()){
-for(ObjectType extInterface : functionType.getExtendedInterfaces()){
-if(extInterface.getConstructor()!=null&&!extInterface.getConstructor().isInterface()){
-compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
-}
-}
-if(functionType.getExtendedInterfacesCount()>1){
-HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
-HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
-for(ObjectType interfaceType : functionType.getExtendedInterfaces()){
-currentProperties.clear();
-checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
-properties.putAll(currentProperties);
-}
-}
-}
-}
 }

PATTERN : /home/jiajun/GithubData/2015/V31/1697/pattern-ver1-serial/yamcs-core.src.main.java.org.yamcs.xtceproc.AlarmChecker.java-performAlarmCheckingEnumerated.pattern
MATCHLEVEL : ALL
ALL : 153, UPD : 0, INS : 0, DEL : 153
Failing Tests:[com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces]
---------START : 2019.09.10 AD at 05:31:39 CDT
---------TIME : 2019.09.10 AD at 10:31:40 CDT
--------------- END -----------------
Finish : closure-2 > patch : 3 | Start : Tue Sep 10 05:31:39 CDT 2019 | End : 2019.09.10 AD at 10:31:40 CDT
